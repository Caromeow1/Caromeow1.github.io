[{"title":"Unity进阶：UGUI框架的搭建","path":"/2023/09/25/Unity进阶：UGUI框架的搭建/","content":"发现了一篇很好的UI框架，学习一下，按照自己的理解分享出来 原文：【Unity】游戏UI框架（基于UGUI）_unity ugui框架_Torta_two的博客-CSDN博客 运行效果： 基本架构： 具体实现： 如何使用：","tags":["Unity","UGUI框架"]},{"title":"Unity小功能：简易背包的实现","path":"/2023/09/23/Unity小功能：简易背包的实现/","content":"想学习一个背包功能的实现，在B站看了几个视频，感觉都有不符合自己习惯的部分，于是把各家结合起来，自己琢磨了一个，目前只有简陋的功能，还有待完善 （今天用了一下Rider，真的好用，十分人性化，比如打大括号自动会把后面的内容框起来，代码整理会删除多余行，颜色也比VS好看，感觉敲代码的速度瞬间变快，狠狠滴用起来！） 效果演示： 制作思路： 整体逻辑： 物品被拾取 👉 调用拾取者的PickUp方法 👉 调用拾取者背包的AddItem方法，将该物体加入到列表中 👉 更新背包中的对应格子 点击丢弃物品 👉 物体列表减去对应数量，减完就移除该物品 👉 更新格子 （当然还有各种逻辑判断） 设计背包类： 先简单写一下背包面板的打开关闭逻辑 1234567891011121314151617181920212223242526272829private void InventoryControl()&#123; if (Input.GetKeyDown(KeyCode.I))// 按下 I 键时 &#123; // 如果游戏是运行状态，暂停游戏，打开菜单 if (!GameManager.instance.isPause) &#123; Pause(); &#125; else // 如果游戏是暂停状态，关闭菜单，继续游戏 &#123; Resume(); &#125; &#125;&#125;private void Pause()&#123; inventoryMenu.SetActive(true); Time.timeScale = 0f; GameManager.instance.isPause = true;&#125;private void Resume()&#123; inventoryMenu.SetActive(false); Time.timeScale = 1f; GameManager.instance.isPause = false;&#125; 用三个列表存储玩家所拥有物品的信息（字典在监视器窗口看不到，不太好调试所以没使用） 123public List&lt;Item&gt; items = new List&lt;Item&gt;(); // 玩家持有的物品public List&lt;int&gt; itemNums = new List&lt;int&gt;(); // 每个物品对应的数量public List&lt;int&gt; itemIndex = new List&lt;int&gt;(); // 每个物品对应的背包格子的索引 加入了背包格子索引主要是想后面实现拖拽换位的功能（先挖坑） 往背包中加入物品 如果背包中已经有这个物品，增加这个物品的数量，没有的话再开新的位置存放，因为背包面板的格子位置和物品列表的存放顺序并不一样，所以需要单独判断，遍历寻找空的格子，然后更新格子的信息，同时物品也需要知道自己存放在哪个格子里，存放完毕后，判断背包是否满了（格子的数量为背包容量），背包满了后再拾取物品的逻辑判断在 CanPicked 类中处理，进不来这里 1234567891011121314151617181920212223public void AddItem(Item item, int itemNum)&#123; if (items.Contains(item)) // 如果背包存在该物品 &#123; itemNums[items.IndexOf(item)] += itemNum; // 该物品数量增加 slots[itemIndex[items.IndexOf(item)]].Show(item, itemNums[items.IndexOf(item)]); // 更新该物品对应的背包格子 &#125; else // 如果背包不存在该物品 &#123; items.Add(item); // 玩家持有物品列表里增加该物品信息和数量 itemNums.Add(itemNum); foreach (Slot slot in slots) // 寻找空的背包格，将物品信息放入 &#123; if (!slot.isNull) continue; itemIndex.Add(slot.index); slot.Show(item, itemNums[items.IndexOf(item)]); slot.isNull = false; break; &#125; if (items.Count == slots.Length) isFull = true; &#125;&#125; （写完之后发现一个坑，就是加入物品不一定是在地上拾取，比如NPC的任务奖励，这时候就需要再次判断背包满了没有，比较麻烦，以后再实现一下类内判断） 移除背包中的物品 移除物品的操作是点击背包格子右上角的 × ，点击一次移除指定数量，暂时为1 如果背包中存在这个物品，且数量多于要移除的数量，就只需把物品数量减一下；如果数量刚好相等，就直接移除这个物品，如果数量不足直接报提醒。移除物品也可能不通过菜单，比如出售给商人，所以也有背包中不存在这个物品的可能 同时不要忘了更新格子信息 123456789101112131415161718192021222324252627public void RemoveItem(Item item, int itemNum)&#123; if (items.Contains(item)) // 如果背包存在该物品 &#123; if (itemNums[items.IndexOf(item)] &gt; itemNum) // 背包里该物品数量多于需要移除的数量 &#123; itemNums[items.IndexOf(item)] -= itemNum; slots[itemIndex[items.IndexOf(item)]].Show(item, itemNums[items.IndexOf(item)]); // 更新对应的背包格子 &#125; else if (itemNums[items.IndexOf(item)] == itemNum) // 背包里该物品数量等于需要移除的数量 &#123; slots[itemIndex[items.IndexOf(item)]].Hide(); // 物品对应的背包格子清空 itemIndex.RemoveAt(items.IndexOf(item)); itemNums.RemoveAt(items.IndexOf(item)); items.Remove(item); isFull = false; // 当前格子物品移除完毕，背包就多了一个空格子 &#125; else if (itemNums[items.IndexOf(item)] &lt; itemNum) // 背包里该物品数量不足 &#123; Debug.Log(&quot;没有足够的物品&quot;); &#125; &#125; else // 如果背包不存在该物品 &#123; Debug.Log(&quot;你没有持有该物品&quot;); &#125;&#125; 背包有了，角色就可以拿上自己的背包啦（但是因为是新手背包，所以只有三格） 1private InventoryManager myInventory; 玩家角色类主要是捡起和丢掉物品的方法，虽然可能不需要通过玩家类（后来想了一下必须通过玩家类，因为玩家的背包自己拿着自己才能控制，从其他地方控制的不是玩家的背包） 123456789public void PickUpItem(Item item, int itemNum)&#123; myInventory.AddItem(item, itemNum);&#125;public void ThrowAwayItem(Item item, int itemNum)&#123; myInventory.RemoveItem(item, itemNum);&#125; 移除物品的按钮逻辑也写在玩家类中，因为点击按钮这个动作也是玩家做出的嘛 12345public void OnClickCloseButton()&#123; GameObject currentButton = EventSystem.current.currentSelectedGameObject; // 获取当前点击到的按钮 ThrowAwayItem(currentButton.GetComponentInParent&lt;Slot&gt;().currentItem, 1);&#125; Slot格子类 感觉写的稍微有点麻烦，不过能运行就是最好的代码 一些格子的信息： （index需要在监视器面板自己填写） 123456public bool isNull;// 该格子目前是否为空public Image itemImage;public Text itemNumText;public Button closeButton;public int index;// 该格子在整个背包中的位置public Item currentItem;// 改格子当前存储的是哪个物品 显示（更新）格子： 隐藏格子（直接隐藏了所以里面的图片数字啥的没改也无所谓啦）： 123456789public void Hide()&#123; itemImage.gameObject.SetActive(false); itemNumText.gameObject.SetActive(false); closeButton.gameObject.SetActive(false); currentItem = null; isNull = true;&#125; Item类 创建继承 ScriptableObject 的 Item 类，用这个类创建出一个个物体 1234public string itemName;// 物体名字public string itemDes;// 物体描述public Sprite itemSprite;// 物体图片public int itemPrice;// 物体价格 CanBePicked类挂载在场景中的每个可拾取物体上 用来处理被玩家触碰到时的逻辑 12345678910111213141516private void OnTriggerEnter2D(Collider2D collision)&#123; if (collision.CompareTag(&quot;Player&quot;)) &#123; if (collision.GetComponent&lt;InventoryManager&gt;().isFull &amp;&amp; !collision.GetComponent&lt;InventoryManager&gt;().items.Contains(item)) &#123; Debug.Log(&quot;背包已经爆满了&quot;); &#125; else &#123; gameObject.SetActive(false); collision.GetComponent&lt;PlayerController&gt;().PickUpItem(item, itemNum); &#125; &#125;&#125; 不定时继续更新，目前挖的坑有： 鼠标放置显示物品描述 鼠标点击物品弹出框，分别有选择数量丢弃、使用 物品拖拽 完整代码： Item.cs一个继承了ScriptableObject的物品类，存储了一些物品的信息，用来创建出各个不同的物品 12345678[CreateAssetMenu(menuName = &quot;Item&quot;, fileName = &quot;New Item&quot;)] public class Item : ScriptableObject &#123; public string itemName;// 物体名字 public string itemDes;// 物体描述 public Sprite itemSprite;// 物体图片 public int itemPrice;// 物体价格 &#125; Slot.cs背包菜单里的每一个格子都挂载了Slot类，显示出该格子的一些信息，并提供了显示（刷新）或隐藏格子内物品的方法 12345678910111213141516171819202122232425262728293031public class Slot : MonoBehaviour &#123; public bool isNull;// 该格子目前是否为空 public Image itemImage; public Text itemNumText; public Button closeButton; public int index;// 该格子在整个背包中的位置 public Item currentItem;// 改格子当前存储的是哪个物品 public void Show(Item item, int itemNum) &#123; itemImage.sprite = item.itemSprite; itemNumText.text = itemNum.ToString(); itemImage.gameObject.SetActive(true); itemNumText.gameObject.SetActive(true); closeButton.gameObject.SetActive(true); currentItem = item; &#125; public void Hide() &#123; itemImage.gameObject.SetActive(false); itemNumText.gameObject.SetActive(false); closeButton.gameObject.SetActive(false); currentItem = null; isNull = true; &#125; &#125; CanBePicked.cs挂在在场景中的单个物品上，使物品可以被玩家拾取 12345678910111213141516171819202122public class CanBePicked : MonoBehaviour &#123; public Item item; public int itemNum; private void OnTriggerEnter2D(Collider2D collision) &#123; if (collision.CompareTag(&quot;Player&quot;)) &#123; if (collision.GetComponent&lt;InventoryManager&gt;().isFull &amp;&amp; !collision.GetComponent&lt;InventoryManager&gt;().items.Contains(item)) &#123; Debug.Log(&quot;背包已经爆满了&quot;); &#125; else &#123; gameObject.SetActive(false); collision.GetComponent&lt;PlayerController&gt;().PickUpItem(item, itemNum); &#125; &#125; &#125; &#125; GameManager.cs实现单例模式，用来控制游戏的状态，目前只有 isPause 控制是否暂停（显示背包即为暂停） 12345678910111213141516171819202122public class GameManager : MonoBehaviour &#123; public static GameManager instance; public bool isPause; private void Awake() &#123; if (instance == null) &#123; instance = this; &#125; else &#123; if (instance != this) &#123; Destroy((gameObject)); &#125; &#125; DontDestroyOnLoad(gameObject); &#125; &#125; InventoryManager.cs背包类，拥有了该类的物体即为拥有了自己的背包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class InventoryManager : MonoBehaviour &#123; public GameObject inventoryMenu; public List&lt;Item&gt; items = new List&lt;Item&gt;(); // 玩家持有的物品 public List&lt;int&gt; itemNums = new List&lt;int&gt;(); // 每个物品对应的数量 public List&lt;int&gt; itemIndex = new List&lt;int&gt;(); // 每个物品对应的背包格子的索引 public Slot[] slots; // 背包中显示的物品格子 public bool isFull; private void Start() &#123; inventoryMenu.SetActive(false); &#125; private void Update() &#123; InventoryControl(); &#125; private void InventoryControl() &#123; if (Input.GetKeyDown(KeyCode.Escape)) &#123; // 如果游戏是运行状态，暂停游戏，打开菜单 if (!GameManager.instance.isPause) &#123; Pause(); &#125; else // 如果游戏是暂停状态，关闭菜单，继续游戏 &#123; Resume(); &#125; &#125; &#125; private void Pause() &#123; inventoryMenu.SetActive(true); Time.timeScale = 0f; GameManager.instance.isPause = true; &#125; private void Resume() &#123; inventoryMenu.SetActive(false); Time.timeScale = 1f; GameManager.instance.isPause = false; &#125; public void AddItem(Item item, int itemNum) &#123; if (items.Contains(item)) // 如果背包存在该物品 &#123; itemNums[items.IndexOf(item)] += itemNum; // 该物品数量增加 slots[itemIndex[items.IndexOf(item)]].Show(item, itemNums[items.IndexOf(item)]); // 更新该物品对应的背包格子 &#125; else // 如果背包不存在该物品 &#123; items.Add(item); // 玩家持有物品列表里增加该物品信息和数量 itemNums.Add(itemNum); foreach (Slot slot in slots) // 寻找空的背包格，将物品信息放入 &#123; if (!slot.isNull) continue; itemIndex.Add(slot.index); slot.Show(item, itemNums[items.IndexOf(item)]); slot.isNull = false; break; &#125; if (items.Count == slots.Length) isFull = true; &#125; &#125; public void RemoveItem(Item item, int itemNum) &#123; if (items.Contains(item)) // 如果背包存在该物品 &#123; if (itemNums[items.IndexOf(item)] &gt; itemNum) // 背包里该物品数量多于需要移除的数量 &#123; itemNums[items.IndexOf(item)] -= itemNum; slots[itemIndex[items.IndexOf(item)]].Show(item, itemNums[items.IndexOf(item)]); // 更新对应的背包格子 &#125; else if (itemNums[items.IndexOf(item)] == itemNum) // 背包里该物品数量等于需要移除的数量 &#123; slots[itemIndex[items.IndexOf(item)]].Hide(); // 物品对应的背包格子清空 itemIndex.RemoveAt(items.IndexOf(item)); itemNums.RemoveAt(items.IndexOf(item)); items.Remove(item); isFull = false; // 当前格子物品移除完毕，背包就多了一个空格子 &#125; else if (itemNums[items.IndexOf(item)] &lt; itemNum) // 背包里该物品数量不足 &#123; Debug.Log(&quot;没有足够的物品&quot;); &#125; &#125; else // 如果背包不存在该物品 &#123; Debug.Log(&quot;你没有持有该物品&quot;); &#125; &#125; &#125; PlayerController.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class PlayerController : MonoBehaviour &#123; private float horizontal; private float vertical; public float speed; public InventoryManager myInventory; private void Update() &#123; Move(); &#125; private void Move() &#123; horizontal = Input.GetAxisRaw(&quot;Horizontal&quot;); vertical = Input.GetAxisRaw(&quot;Vertical&quot;); transform.Translate(new Vector2(horizontal * speed * Time.deltaTime, vertical * speed * Time.deltaTime)); transform.localScale = horizontal switch &#123; &gt; 0 =&gt; new Vector3(0.8f, 0.8f, 0.8f), &lt; 0 =&gt; new Vector3(-0.8f, 0.8f, 0.8f), _ =&gt; transform.localScale &#125;; &#125; /// &lt;summary&gt; /// 捡起物品 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;捡起的物品&lt;/param&gt; /// &lt;param name=&quot;itemNum&quot;&gt;捡起的物品数量&lt;/param&gt; public void PickUpItem(Item item, int itemNum) &#123; myInventory.AddItem(item, itemNum); &#125; public void ThrowAwayItem(Item item, int itemNum) &#123; myInventory.RemoveItem(item, itemNum); &#125; public void OnClickCloseButton() &#123; GameObject currentButton = EventSystem.current.currentSelectedGameObject;// 获取当前点击到的按钮 ThrowAwayItem(currentButton.GetComponentInParent&lt;Slot&gt;().currentItem, 1); &#125; &#125;","tags":["Unity","背包"]},{"title":"Unity小功能：随机播放列表中的歌曲","path":"/2023/09/16/Unity小功能：随机播放列表中的歌曲/","content":"核心思想为：记录暂时没有播放的歌曲，每次播放完毕后从中随机抽取一首进行播放，并将这首歌从未播放列表移除，所有歌曲都播放一遍后，填充未播放列表 首先准备几首歌，并存入歌曲数组 声明一个整形变量，记录当前播放歌曲在数组中的下标，声明一个列表，记录暂时未播放歌曲的下标 并对列表进行初始化 随机从未播放列表中选取一个值，作为将要播放的歌曲，并从未播放列表中移除 准备完毕，开始播放音乐，通过协程的 yield return new WaitForSeconds 模拟歌曲播放完毕切歌 别忘了把准备好的歌拖进歌曲数组中 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System.Collections;using System.Collections.Generic;using UnityEngine;public class AudioManager : PersistentSingleton&lt;AudioManager&gt;&#123; public AudioSource bGMPlayer;// 获取播放器 public AudioClip[] bGMClips;// 歌曲音频数组 public int index;// 正在播放的歌曲在数组中的位置 public List&lt;int&gt; unPlayedIndex;// 暂时未播放歌曲的index private void Start() &#123; InitiaList(); StartCoroutine(ChangeBGMCoroutine()); &#125; /// &lt;summary&gt; /// 初始化未播放歌曲列表，默认所有歌曲均未播放，列表填充满 /// &lt;/summary&gt; private void InitiaList() &#123; unPlayedIndex = new List&lt;int&gt;(bGMClips.Length); for (int i = 0; i &lt; unPlayedIndex.Capacity; i++) &#123; unPlayedIndex.Add(i); &#125; &#125; /// &lt;summary&gt; /// 随机选取未播放列表中的一个index值 /// &lt;/summary&gt; private void ChangeIndex() &#123; if (unPlayedIndex.Count == 0) &#123; InitiaList(); &#125; index = unPlayedIndex[Random.Range(0, unPlayedIndex.Count)]; // 选取之后，从列表中移除当前index值 unPlayedIndex.Remove(index); &#125; /// &lt;summary&gt; /// 切歌协程，歌曲播放完毕之后，随机选取一首歌继续播放 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator ChangeBGMCoroutine() &#123; while (true) &#123; bGMPlayer.Stop(); ChangeIndex(); bGMPlayer.clip = bGMClips[index]; bGMPlayer.Play(); // 等待一段时间，该时间为歌曲长度，等待结束即为歌曲播放完毕 yield return new WaitForSeconds(bGMPlayer.clip.length); &#125; &#125;&#125;","tags":["Unity","小功能","随机播放"]},{"title":"Unity：UGUI基础","path":"/2023/09/13/Unity：UGUI基础/","content":"Canvas与三种画布渲染模式Canvas简介Canvas画布是承载所有UI元素的区域。Canvas实际上是一个挂载着Canvas组件的游戏对象。所有的UI元素都必须是Canvas的子对象。我们创建任何一个UI元素时，如果场景中没有Canvas画布，就会自动创建画布，并且将新元素置于其下。 Canvas画布参数 RenderModeScreen Space-Overlay模式Screen Space-Overlay（屏幕空间-覆盖）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕，如下图效果： （在此模式下，虽然在Canvas前放置了3D人物，但是在Game窗口中并不能观察到3D人物） Screen Space-Overlay模式的画布有 Pixel Perfect 和 Sort Layer 两个参数： （1）Pixel Perfect：只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。 （2）Sort Layer: Sort Layer是UGUI专用的设置，用来指示画布的深度。 Screen Space-Camera模式 Screen Space-Camera（屏幕空间-摄影机模式）和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。 这种模式可以用来实现在UI上显示3D模型的需求，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求，效果如下图所示： 它比Screen Space-Overlay模式的画布多了下面几个参数： （1）Render Camera：渲染摄像机 （2）Plane Distance：画布距离摄像机的距离 （3）Sorting Layer：Sorting Layer是UGUI专用的设置，用来指示画布的深度。可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。 可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。 （4）Order in Layer:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。 World Space模式 World Space即世界控件模式。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时， 可以使用这个模式。 它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。 这种模式可以用来实现跟随人物移动的血条或者名称，如下图所示： 我们通过下面的表格可以对比一下三种渲染模式的区别： 渲染模式 画布对应屏幕 摄像机 像素对应 适合类型 Screen Space-Overlay 是 不需要 可选 2D UI Screen Space-Camera 是 需要 可选 2D UI World Space 否 需要 不可选 3D UI 使UI跟随屏幕分辨率变化自适应为什么需要UI自适应 场景1：手机需要再竖屏与横屏之间切换，这样适应竖屏的UI元素的位置，未必适应横屏 场景2：即使都采用横屏模式，手机的横纵比不同，有的是2140x1080，有的是2400x1080，有的是1920x1080，等等… 场景3：即使都采用相同横纵比，但屏幕分辨率不同，例如：1920x1080与2560x1440 Canvas Scaler 组件中的参数：UI Scale Mode 一、Constant Pixel Size像素大小始终不变，即一个100100的图片在任何的分辨率下都占用100100的像素。简单比较好理解。Scale Factor是表示缩放倍数。比如是2时，即将上面图片整体是缩放两倍是不变形的。 二、Scale With Screen Size这种模式应用场景多一点。首先逐个说明下： 1）Reference Resolution是开发时的分辨率。以后缩放就参考它。 2）Screen Match Mode又包含三种模式 Match Width Or Height：下面包含一个Macht属性，当处于最左边时，屏幕高度对于UI大小完全没有任何影 响，只有宽度会对UI大小产生影响。假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference Resolution设置参数的x倍。也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸 ，当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响 ，处于中间某处时，对上述两者的影响进行权重加成 。所以一般我们都把其放在0.5的位置（0.618也很舒服哦）。 Expand 缩放不剪切：当屏幕分辨率与设定不同时，选择变化较小的一个方向（横向还是纵向），进行缩放显示，它会保证设计时分辨率能显示出来的缩放后依然能显示出来。 Shrink 缩放剪切：当屏幕分辨率与设定不同时，选择变化较大的一个方向（横向还是纵向）进行缩放显示，对于超出的部分剪切不显示。 三、Constant Physical Size保持物理上不变的方式，这个应用场景较少，具体是这样的，比如你电脑分辨率是 10002000而你的手机分辨率也是10002000。虽然电脑屏幕比手机屏幕大的多，但是他们最后显示出来图片的物理大小是一样的。 实例演示目标： 角落的四个按钮在任何分辨率都能正常显示 Hierarchy布局： Canvas组件设置： Image的Rect Transform组件设置： Button组件Rect Transform组件设置： 效果展示： 1920 x 1080： 800 x 600： 1080 x 1920：","tags":["Unity","UGUI"]},{"title":"多级渐远纹理Mipmap","path":"/2023/09/13/多级渐远纹理Mipmap/","content":"百度百科 MIP来源于拉丁文中的multum in parvo，意为在一个小空间里的多数。MIP map技术与材质贴图技术结合，根据距观看者远近距离的不同，以不同的分辨率将单一的材质贴图以多重图像的形式表现出来并代表平面纹理：尺寸最大的图像放在前面显著的位置，而相对较小的图像则后退到背景区域。每一个不同的尺寸等级定义成一个MIP map水平。MIP map技术帮助避免了不想要的锯齿边缘（称为锯齿状图形）在图像中出现，这种锯齿状图形可能是由于在不同分辨率下使用bit map图像产生的。 先了解纹理过滤 想要了解为什么要使用Mipmap，首先要知道纹理过滤是什么。 当你在玩吃鸡的时候可能会发现一个现象，一个人在距离你5米的地方，可以观察到敌人的一举一动，包括身上的装备等等，但当你拿到98k时，你会蹲在远处狙击别人，这时不开镜的你看500米远处的敌人只能看到一个黑点，这其中远近看到的区别就有应用到纹理过滤。 游戏中A物体的游戏设计纹理贴图是400*400Texel(纹理像素) 1.当你(摄像机)跟A物体的距离为0时，在你屏幕上显示的像素就是400*400，跟贴图的纹理像素大小相同，此时不需要做特殊处理 2.假设你离A物体10米远时,屏幕显示的pix为200200,当200200的像素要显示400400纹理像素的物体时，此时的一颗像素需要映射22的纹理像素，这个时候就有个问题了，这颗像素要显示什么颜色？只能用合适的算法在这2*2里的纹理像素中计算得出，在这里引用OpenGL中的邻近过滤和线性过滤： GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： 临近过滤 GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： 线性过滤 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）： 左为临近过滤，右为线性过滤 当距离很远的时候怎么算 此时的你来到远离市区500米的山上，想要狙击别人，你只能看到一个个很小的人影，在不开镜的情况下只能看到人的跑动。 此时敌人在屏幕显示为2020，400400的纹理像素映射在2020的像素内，一颗像素需要映射2020的纹理像素，如果直接进行纹理过滤，那么在使用线性过滤的情况下，只会使用纹理坐标映射点的周围4颗纹理像素进行计算，那么其他的396颗纹理像素就没了参考价值，考虑极端情况下，如果纹理坐标映射点在人的头发，那么不就只是显示黑色了？ ，那么在最终的显示效果上可能会产生锯齿或者摩尔纹，摩尔纹长这样： 摩尔纹 这视觉效果必须得改善，那我不能参考所有需要映射的纹理像素进行平均取色吗？可以，但是你的GPU允许你这么做吗，有兴趣可以做个实验，自己采样所有纹理像素进行纹理过滤，此时你如果远处的模型较多的情况下， 使用原生的线性过滤：60FPS，渲染一个物体每颗像素的颜色需要计算4个纹理像素的插值。 采样所有纹理像素进行纹理过滤：1FPS,渲染一个物体每颗像素的颜色需要采样计算400个纹理像素的插值。 可以想象性能换质量的消耗实在太大，在如今的GPU算力下是施行不了的. 那有办法不损耗算力，又可以提升显示质量吗？可以，使用Mipmap. Mipmap概念 想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 Mipmap效果 Mipmap 上图是Mipmap的纹理，在储存上最大的为mipmap0，mipmap1的分辨率为mipmap0的一半,以此一直创建下去，直到纹理为一个像素时停止，在某些引擎中可以设置Mipmap的强弱，也就是Mipmap的创建次数。但一般直接拉到最强，因为越到后面创建的大小越小，占用的内存也就越小。 Mipmap效果 不使用Mipmap： 在先前讲的1颗像素需要映射2020的纹理像素时，显示效果失真，锯齿以及可能会产生摩尔纹，发生的原因是在纹理过滤时，一颗像素只采样了原本2020纹理像素里2*2纹理像素的颜色进行线性插值，得到最终的颜色，其他的396颗纹理像素无用，浪费显存且取色不精确。 使用Mipmap:Mipmap创建：预先创建原纹理大小2分之一的多级渐远纹理，在多级渐远纹理取色采样时，也会进行线性过滤，可以理解成预先创建每隔一定阈值(也就是每次映射像素为上一级别多级渐远纹理的2分之一的时候）并经过了线性过滤的纹理。 使用Mipmap的渲染过程：2020的像素需要映射400400的纹理像素时，检测到一颗像素需要映射到纹理像素为2020，在Mipmap纹理中里寻找最接近2020纹理像素的多级渐远纹理，并使用此多级渐远纹理进行采样。 此时采样用的多级渐远纹理的颜色也是从上一级的多级渐远纹理迭代采样插值计算而来，也就是一颗像素映射此多级渐远纹理间接插值计算了2020的纹理像素的颜色，取色的效果当然比一颗像素直接映射原图2020只采样了2*2的纹理像素颜色进行线性插值要好得多，使用Mipmap就避免了采样的纹理像素过少而失真， 理论上点对点的映射最为精确，而如果最邻近的子纹理跟20*20无法点对点采样映射，还可以设置多级渐远纹理的过滤方式 过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 Mipmap的优点与缺点 优点:1.质量高：避免了在远距离情况下的采样频率低和数据频率高造成的失真和摩尔纹，效果比无Mipmap好得多。 2.性能好：避免了不使用Mipmap下距离远时采样频率低和数据频率高而照成texture cache命中率不高(相邻Pixel采样Texel时uv相差比较大)使性能下降。 缺点：1.占用显存，可使用ue的纹理流缓存优化（IO换显存）。 Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的板栗.的博客-CSDN博客","tags":["Mipmap"]},{"title":"设计模式：对象池系统","path":"/2023/09/10/设计模式：对象池系统/","content":"想象一下我正在做一个丧尸围城小游戏，丧失源源不断袭来，而我的角色需要不停消灭它们，并升级武器应对更猛烈的攻击。 如何处理丧尸生成逻辑？初学者的我想到的第一个方法就是把丧失拖成预制体，Instantiate 它并设置一个随机位置，当它死亡时调用 Distory() 销毁游戏物体。但是当我把角色射出的子弹、枪口特效、丧失死亡掉落的经验特效都这样处理，随着游戏进行，我的电脑变得越来越卡。 这是因为游戏物体的频繁创建和销毁会占用大量内存空间，频繁调用GC占用大量性能。怎么处理呢？ 对象池（Object Pool）创建一个池子，把游戏可能会用到的资源提前创建，用到的时候将它 取出 SetActive(true) 并放到正确的位置，用完之后再 回收 SetActive(false) 而不是销毁，用空间换时间很好地解决了问题。 代码实现Pool.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[System.Serializable]// Serializable 特性可以在监视器窗口调整对象池内容public class Pool&#123; public GameObject prefab;// 存入的物体 Queue&lt;GameObject&gt; objectPool;// 内存区（队列）池子本体 public int defaultSize;// 对象池初始容量 public int maxSize;// 对象池最大容量，防止对象池无节制占用内存 Transform parent;// 创建这个池子的物体时指定所属的父物体 /// &lt;summary&gt; /// 对池子进行初始化，创建初始容量个数的物体，存入队列中 /// &lt;/summary&gt; /// &lt;param name=&quot;parent&quot;&gt;创建这个池子的物体时指定所属的父物体&lt;/param&gt; public void Initialize(Transform parent) &#123; objectPool = new Queue&lt;GameObject&gt;();// 初始化队列 this.parent = parent; for (int i = 0; i &lt; defaultSize; i++) &#123; Copy(); &#125; &#125; /// &lt;summary&gt; /// 创建物体，并放入对象池中 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public GameObject Copy() &#123; GameObject copy = GameObject.Instantiate(prefab, parent);// 实例化物体 objectPool.Enqueue(copy);// 将实例化的物体入列 copy.SetActive(false);// 隐藏该物体 return copy; &#125; /// &lt;summary&gt; /// 从对象池中拿出物体 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public GameObject GetObject() &#123; GameObject getObject; if (objectPool.Count &gt; 0 &amp;&amp; !objectPool.Peek().activeSelf)// 对象池中有物体，就拿出 &#123; getObject = objectPool.Dequeue(); &#125; else// 对象池被拿空了还需要，就再创建一个 &#123; getObject = Copy(); &#125; getObject.SetActive(true); return getObject; &#125; /// &lt;summary&gt; /// 回收物体到池子中 /// &lt;/summary&gt; /// &lt;param name=&quot;recycle&quot;&gt;&lt;/param&gt; public void RecycleObject(GameObject recycle) &#123; if (objectPool.Count &lt;= maxSize)// 池子中的物体不超过最大容量 &#123; if(!objectPool.Contains(recycle))// 该对象没有在队列中 &#123; objectPool.Enqueue(recycle); recycle.SetActive(false); &#125; &#125; else// 超过最大容量就销毁 &#123; GameObject.Destroy(recycle); &#125; &#125;&#125; PoolManager.cs1234567891011121314151617181920212223242526272829303132333435363738public class PoolManager : MonoBehaviour&#123; // 此处创建游戏中用到的池子 public Pool[] bulletPools; public static Dictionary&lt;GameObject, Pool&gt; dic;// 将游戏物体和所在的池子绑定到字典中 private void Awake() &#123; dic = new Dictionary&lt;GameObject, Pool&gt;(); Initialize(bulletPools); &#125; /// &lt;summary&gt; /// 初始化游戏对象，设置父物体 /// &lt;/summary&gt; /// &lt;param name=&quot;pools&quot;&gt;&lt;/param&gt; void Initialize(Pool[] pools) &#123; foreach (Pool pool in pools) &#123; dic.Add(pool.prefab, pool); Transform poolParent = new GameObject(&quot;Pool: &quot; + pool.prefab.name).transform; poolParent.parent = transform; pool.Initialize(poolParent); &#125; &#125; /// &lt;summary&gt; /// 根据传入的prefab，返回对象池中准备好的游戏对象 /// &lt;/summary&gt; /// &lt;param name=&quot;prefab&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static GameObject Release(GameObject prefab) &#123; return dic[prefab].GetObject(); &#125;&#125; 应用实例增加一个 PoolManager 类的 Release 方法的重载，使物体创建时有一个初始位置： 12345public static GameObject Release(GameObject prefab, Vector3 position)&#123; prefab.transform.position = position; return dic[prefab].GetObject();&#125; 新建一个子弹类，包含子弹的移动与撞击物体时销毁（不是真的销毁，只是隐藏） Bullet.cs1234567891011121314151617181920public class Bullet : MonoBehaviour&#123; float moveSpeed = 0.1f; void FixedUpdate() &#123; if (gameObject.activeSelf) &#123; transform.Translate(moveSpeed * new Vector3(1, 0, 0)); &#125; &#125; private void OnCollisionEnter(Collision collision) &#123; if (gameObject.activeSelf &amp;&amp; collision.gameObject.name == &quot;Cube&quot;) &#123; gameObject.SetActive(false); &#125; &#125;&#125; 在游戏控制脚本中控制子弹射出 GameController.cs12345678910111213public class GameController : MonoBehaviour&#123; public GameObject bullet; public Transform bulletPos; private void Update() &#123; if (Input.GetMouseButtonDown(0)) &#123; PoolManager.Release(bullet, bulletPos.transform.position); &#125; &#125;&#125; 运行图片","tags":["Unity","设计模式","对象池"]},{"title":"数据结构与算法：排序","path":"/2023/09/09/数据结构与算法-排序/","content":"冒泡排序（Bubble Sort）排序方法：（以下均为从小到大的正序排序）从数组的第一位向后，依次比较相邻的两个数据，如果前面的数据大于后面的数据，则两个元素交换位置。 代码实现：12345678910111213141516171819202122232425262728Console.WriteLine(&quot;请输入需要排序的一组数字，以英文符号 &#x27;,&#x27; 分隔：&quot;);string inputStr = Console.ReadLine();// 获取用户输入字符串string[] numsStr = inputStr.Split(&#x27;,&#x27;);// 将用户输入存入String数组int[] nums = new int[numsStr.Length];// 将String数组转为int数组（以后使用直接声明的数组）for (int i = 0; i &lt; numsStr.Length; i++)&#123; nums[i] = int.Parse(numsStr[i]);&#125;for (int i = 0; i &lt; nums.Length - 1; i++)// 外围循环每轮将一个最大数字送到最后&#123; for (int j = 0; j &lt; nums.Length - 1 - i; j++)// 内部循环每轮挑选较大数字并交换位置 &#123; if (nums[j] &gt; nums[j + 1])// 如果前面数大于后面数，两数交换位置 &#123; int temp = nums[j + 1]; nums[j + 1] = nums[j]; nums[j] = temp; &#125; &#125;&#125;Console.WriteLine(&quot;排序结果为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125; 运行结果： 选择排序（ Selection Sort）排序方法将数组分为排序区和未排序区，遍历未排序区的元素找到最小值，将它放在未排序区的第一位。 代码实现1234567891011121314151617181920212223242526272829int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;;Console.WriteLine(&quot;原数组为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125;for (int i = 0; i&lt; nums.Length - 1; i++)&#123; int minIndex = i;// 记录最小数字的下标 for (int j= i + 1; j&lt; nums.Length; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j;// 更新最小数字的下标 &#125; &#125; // 找到最小数字之后与未排序区的第一个数交换位置 int temp = nums[i]; nums[i] = nums[minIndex]; nums[minIndex] = temp;&#125;Console.WriteLine(&quot; 排序结果为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125; 运行结果 插入排序（Insertion Sort）排序方法：将数组分为已排序区域和未排序区域，将未排序区域的数依次与已排序区域的数比较并插入到正确位置，如果比它大则交换位置，如果比它小则位置不变并插入。 代码实现：1234567891011121314151617181920212223242526int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;;Console.WriteLine(&quot;原数组为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125;for (int i = 1; i &lt; nums.Length; i++)// 默认第一个数已排序，遍历未排序区的每一个数&#123; int sortNum = nums[i];// 当前正在插入的数 for (int j = i - 1; j &gt;= 0; j--)// 从后往前遍历已排序区的数 &#123; if (nums[j] &gt; sortNum)// 选择正确的位置并插入 &#123; nums[j + 1] = nums[j]; nums[j] = sortNum; &#125; &#125;&#125;Console.WriteLine(&quot; 排序结果为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125; 运行结果： 希尔排序（Shell’s Sort）排序方法是插入排序的升级版，加入了分组的规则，将数组分成多个子数组分别进行插入排序。 代码实现在插入排序的代码外围套一层for循环，加入了步长的概念，相当于普通插入排序的步长一直为1，希尔排序将1替换为步长。 1234567891011121314151617181920212223242526272829int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;;Console.WriteLine(&quot;原数组为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125;for (int step = nums.Length / 2; step &gt; 0; step /= 2)// 步长step初始为数组长度的1/2，每次循环变为原步长的1/2&#123; for (int i = step; i &lt; nums.Length; i += step)// 每次指针的加减不为1，改为步长 &#123; int sortNum = nums[i]; for (int j = i - step; j &gt;= 0; j -= step) &#123; if (nums[j] &gt; sortNum) &#123; nums[j + step] = nums[j]; nums[j] = sortNum; &#125; &#125; &#125;&#125;Console.WriteLine(&quot; 排序结果为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125; 运行结果 快速排序（Quick Sort）排序方法：是对冒泡排序的改进，通过一趟排序将要排序的数据分割成两部分，其中一部分的所有数据都比另一部分的所有数据小，然后对两部分再次进行快速排序，递归直到排序完成。 快速排序首先会在序列中随机选择一个基准值，然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。[ 比基准值小的数] 基准值 [ 比基准值大的数]接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据 进行排序时同样也会使用快速排序。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;;Console.WriteLine(&quot;原数组为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125;void QuickSort(int[] nums, int left, int right)&#123; if (left &gt;= right)// 若数组的左端下标大于或等于右端下标，则表明数组为一或空 &#123; return;// 结束递归 &#125; int i = left; int j = right; int pivot = nums[left];// 取当前数组第一个数为基准数，并记录 while(i &lt; j)// 当i = j时退出，表示pivot左边的数都比pivot小，右边的数都比pivot大 &#123; while(i &lt; j &amp;&amp; pivot &lt;= nums[j])// 从后往前找比pivot小的数 &#123; j--; &#125; while (i &lt; j &amp;&amp; nums[i] &lt;= pivot)// 从前往后找比pivot大的数 &#123; i++; &#125; if (i &lt; j)// 交换数组中大于基准值的数和小于基准值的数 &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; // 将基准值放到大数组和小数组中键 nums[left] = nums[i]; nums[i] = pivot; QuickSort(nums, left, i - 1);// 对比新的轴小的部分递归排序 QuickSort(nums,i + 1, right);// 对比新的轴大的部分递归排序&#125;QuickSort(nums, 0, nums.Length - 1);// 调用测试Console.WriteLine(&quot; 排序结果为：&quot;);for (int i = 0; i &lt; nums.Length; i++)&#123; Console.Write(nums[i] + &quot; &quot;);&#125; 运行结果： 归并排序（Merge Sort）排序方法： 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/// &lt;summary&gt;/// 主函数/// &lt;/summary&gt;/// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;static void Main(string[] args)&#123; int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;; Console.WriteLine(&quot;原数组为：&quot;); for (int i = 0; i &lt; nums.Length; i++) &#123; Console.Write(nums[i] + &quot; &quot;); &#125; nums = Merge(nums);// 调用 Console.WriteLine(&quot; 排序结果为：&quot;); for (int i = 0; i &lt; nums.Length; i++) &#123; Console.Write(nums[i] + &quot; &quot;); &#125;&#125;/// &lt;summary&gt;/// 负责排序/// &lt;/summary&gt;/// &lt;param name=&quot;left&quot;&gt;传入的左数组&lt;/param&gt;/// &lt;param name=&quot;right&quot;&gt;传入的右数组&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static int[] Sort(int[] left, int[] right)&#123; int[] array = new int[left.Length + right.Length];// 先准备一个新数组 int leftIndex = 0;// 左数组索引 int rightIndex = 0;// 右数组索引 for (int i = 0; i &lt; array.Length; i++)// for循环目的是填满这个新数组 &#123; // 2.如果一边的数组放完了，则直接放另一边的数 if (leftIndex &gt;= left.Length) &#123; array[i] = right[rightIndex]; rightIndex++; &#125; else if( rightIndex &gt;= right.Length) &#123; array[i] = left[leftIndex]; leftIndex++; &#125; // 1.将左右两数组的数从小到大放入新数组 else if (left[leftIndex] &lt; right[rightIndex]) &#123; array[i] = left[leftIndex]; leftIndex++; &#125; else if (left[leftIndex] &gt; right[rightIndex]) &#123; array[i] = right[rightIndex]; rightIndex++; &#125; &#125; return array;// 返回新数组&#125;/// &lt;summary&gt;/// 负责分组，调用排序/// &lt;/summary&gt;/// &lt;param name=&quot;array&quot;&gt;每次排好序的新数组&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static int[] Merge(int[] array)&#123; // 递归的结束条件 if (array.Length &lt; 2) &#123; return array; &#125; // 数组分两段 int mid = array.Length / 2; // 初始化左右数组 int[] left = new int[mid]; int[] right = new int[array.Length - mid]; for (int i = 0; i &lt; array.Length; i++) &#123; if (i &lt; mid) &#123; left[i] = array[i]; &#125; else if (i &gt;= mid) &#123; right[i - mid] = array[i]; &#125; &#125; // 不断调用Merge直到数组长度为1不能再分，然后进行排序，一层一层向上返回直到返回完整数组 return Sort(Merge(left), Merge(right));&#125; 运行结果： 堆排序（Heap Sort）排序方法：堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的，每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最小（大）堆，依次类推，最终得到排序的序列。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990internal class Program&#123; /// &lt;summary&gt; /// 主函数 /// &lt;/summary&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; static void Main(string[] args) &#123; int[] nums = &#123; 44, 67, 5, 53, 86, 93, 24, 9, 80, 17 &#125;; Console.WriteLine(&quot;原数组为：&quot;); for (int i = 0; i &lt; nums.Length; i++) &#123; Console.Write(nums[i] + &quot; &quot;); &#125; HeapSort(nums, nums.Length); Console.WriteLine(&quot; 排序结果为：&quot;); for (int i = 0; i &lt; nums.Length; i++) &#123; Console.Write(nums[i] + &quot; &quot;); &#125; &#125; /// &lt;summary&gt; /// 堆排序 /// 堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的 /// 每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最小堆，依次类推，最终得到排序的序列。 /// &lt;/summary&gt; /// &lt;param name=&quot;arr&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt; private static void HeapSort(int[] arr, int length) &#123; CreateHeap(arr, length); //从最后的节点进行调整 for (int i = length - 1; i &gt; 0; i--) &#123; //交换堆顶和最后一个节点的元素 int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; //每次交换进行调整 AdjustHeap(arr, 0, i - 1); &#125; &#125; /// &lt;summary&gt; /// 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。 /// 1）n 个结点的完全二叉树，则最后一个结点是第n/2个结点的子树。 /// 2）筛选从第n/2个结点为根的子树开始，该子树成为堆。 /// 3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。 /// 完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。 /// &lt;/summary&gt; private static void CreateHeap(int[] arr, int length) &#123; for (int i = length / 2 - 1; i &gt;= 0; i--) &#123; AdjustHeap(arr, i, length - 1); &#125; &#125; private static void AdjustHeap(int[] arr, int start, int length) &#123; int root = start; int child = root * 2 + 1; while (child &lt;= length) &#123; //若子节点指标在范围内才做比较 if (child + 1 &lt;= length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123; //先比较两个子节点大小，选择最大的 child++; &#125; //如果父节点大於子节点代表调整完毕，直接跳出函数 if (arr[root] &gt; arr[child]) &#123; return; &#125; else &#123; //否则交换父子内容再继续子节点和孙节点比较 int temp = arr[root]; arr[root] = arr[child]; arr[child] = temp; root = child; child = root * 2 + 1; &#125; &#125; &#125; 运行结果：","tags":["C#基础","数据结构与算法","排序"]},{"title":"初学有限状态机","path":"/2023/09/03/初学有限状态机/","content":"想象一下 想象一个场景，你有一个ARPG游戏里的角色，你的角色有很多骚气的动作：蹬墙跳、滑铲、二段跳、滑翔、过肩摔、格挡反击、咸鱼冲刺、吹口哨…… 但是，你的角色并不能在滑铲的时候使出咸鱼冲刺，在滑翔的时候对着敌人使出过肩摔，在挨打的时候对着怪吹口哨，否则其他看到的玩家就会直呼：卧槽，有挂 如果你是Unity菜鸟，你会怎样设计角色控制代码呢，正好我就是菜鸟，我会告诉你应该这样做：声明一溜布尔值来判断角色所处的状态 1234bool isGround;// 在地面上bool isHuaXiang;// 正在滑翔bool isHurt;// 正在挨打…… 当按下动作按键时用if来判断 12if(!isHurt)\tChuiKouShao();// 如果角色没有在挨打，就对着怪吹口哨嘲讽 like this 当然，学过有限状态机的你对着我的嘴就是一巴掌：如果角色的状态和行为不断变得复杂，慢慢的，你会创建114514个条件变量，慢慢的，if层级会越来越多。。然后你交给了我一个新的方法——有限状态机： 有限状态机 FSM，有限状态机，可以枚举出有限多个状态，当满足特定的条件时可以在这些条件中来回切换 有限状态机的核心思想： 拥有有限个的多种状态 当前处于其中一个状态 状态之间可以互相切换 比如游戏中的敌人AI，正常情况下敌人会在特定的路线上来回走动进行巡逻，当玩家发出动静或者首次进入视野时会警觉，这时候玩家再次发出动静或者暴露在视野中敌人就会追击玩家，直到玩家消失在视野中 Unity当中的Animator就是一个FSM： Animator 只不过每个状态里存放的是动画，我们的FSM也会沿用这个思想，只不过状态里存放的是逻辑代码 FSM可以说是一个强化版的 switch case ，判断处于哪个状态，执行对应的逻辑，FSM可以很方便地进行扩展，加入新状态只需继承基类，不用修改原来的代码 一个最简单的有限状态机 FSM思想一：拥有有限个的多种状态 我们首先思考一下敌人有哪些状态，这里我只使用了简单的两种状态： 巡逻 追赶 使用枚举 enum 类型来存储所有的状态便于使用： 12345public enum StateType&#123; Patrol,// 巡逻状态 Chase// 追赶状态&#125; ​ FSM思想二：当前处于其中一个状态 接下来需要知道敌人当前正处于哪种状态，使用一个 StateType 类型的变量来存储 1private StateType currentState; ​ FSM思想三：状态之间可以互相切换 在Update中，做状态之间切换的判断，当前正处于哪种状态，就执行对应状态的响应函数 1234567891011121314private void Update()&#123; switch (currentState) &#123; case StateType.Patrol: OnPatrol();// 巡逻状态的响应函数 break; case StateType.Chase: OnChase();// 追击状态的响应函数 break; default: break; &#125;&#125; ​ 接下来只要补充两个响应函数中的代码逻辑： 12345678910111213141516private void OnPatrol() &#123; if (Vector2.Distance(transform.position, targetPos) &lt; 0.1f) &#123; targetPos = (targetPos == patrolPos1) ? patrolPos2 : patrolPos1; &#125; transform.position = Vector2.MoveTowards(transform.position, targetPos, speed * Time.deltaTime); if (Vector2.Distance(player.position, transform.position) &lt; dangerDistance) &#123; transform.GetComponentInChildren&lt;Text&gt;().text = &quot;Enemy(Chasing)&quot;; enemyMaterial.color = Color.red; currentState = StateType.Chase; &#125; &#125; 1234567891011private void OnChase() &#123; transform.position = Vector2.MoveTowards(transform.position, player.position, speed * Time.deltaTime); if (Vector2.Distance(transform.position, player.position) &gt; dangerDistance) &#123; transform.GetComponentInChildren&lt;Text&gt;().text = &quot;Enemy(patrolling)&quot;; enemyMaterial.color = Color.green; currentState = StateType.Patrol; &#125; &#125; 更复杂点的有限状态机 简单版本的状态机的代码耦合性太大，不便于更改，这时候需要加入一个中间类 状态机管理类 来控制、调用所有的状态；同时为了便于管理，所有的状态都继承自同一个 状态基类 ，这里也可以用接口来实现同样的效果，总体来说就是下面的框架： 每个独立的敌人对象都有一个自己的状态机管理器，这个管理器中存放着敌人的所有状态，通过这个管理器来实现自己当前状态的切换和运行 状态枚举便于规范和使用，用一个枚举来存放游戏中的所有状态 12345public enum StateEnum&#123; Patrol, Chase&#125; 状态机管理器类用字典来存放单个敌人的状态名字和实例，并创建 AddState 函数便于在单个敌人类中对自己拥有状态进行管理 123456789101112131415161718192021public Dictionary&lt;StateEnum, BaseState&gt; stateDic;public GameObject aIObject; // 当前状态机管理器的拥有者public BaseState currentState; // 当前所处于的状态/// &lt;summary&gt;/// 向字典中添加State的方法/// &lt;/summary&gt;/// &lt;param name=&quot;stateEnum&quot;&gt;State名&lt;/param&gt;public void AddState(StateEnum state)&#123; switch (state) &#123; case StateEnum.Patrol: stateDic.Add(state, new PatrolState(this)); break; case StateEnum.Chase: stateDic.Add(state, new ChaseState(this)); break; default: break; &#125;&#125; 状态的基类抽象类，只能被继承。所有状态都具有的共同行为 OnEnter、OnUpdate、OnExit 单个状态类每个状态单独一个类，存放这个状态拥有的逻辑代码，继承于状态基类 角色对象类创建StateMachineManager类的实例，每个角色都有自己专属的状态机，因此StateMachineManager类不能是抽象类","tags":["Unity","learn","有限状态机"]},{"title":"Lua学习笔记","path":"/2023/08/29/Lua学习笔记/","content":"第一个Lua程序1print(&quot;Hello World!&quot;) Lua 语句不用写分号 Lua 注释：单行注释 1--单行注释 多行注释 1234--[[多行注释--]] Lua 标示符Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。 最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。 Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Runoob 与 runoob 是两个不同的标示符。以下列出了一些正确的标示符： 12mohd zara abc move_name a_123myname50 _temp j a23b9 retVal Lua 关键词以下列出了 Lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符： and break do else elseif end false for function if in local nil not or repeat return then true until while goto 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。 Lua 全局变量一般来说，所有变量都是全局的，一个变量没有进行初始化时，他的值默认是 nil Lua 数据类型和 Python 一样，Lua 是动态类型语言，不需要定义变量的类型，尽管赋值 Lua 中有8个基本类型： 数据类型 描述 nil 表示一个无效值或者空值，在条件表达式中相当于false boolean 表示条件：true 和 false number 表示双精度类型的实浮点数，所有数字 string 字符串，用 “” 或 ‘’ 表示 function 函数方法 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序，多线程 table 其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。用 {} 来创建 用 type 函数测试变量或者值的类型： 1234567print(type(&quot;Hello Caromeow&quot;)) --&gt; stringprint(type(114514)) --&gt; numberprint(type(print)) --&gt; functionprint(type(type)) --&gt; functionprint(type(true)) --&gt; booleanprint(type(nil)) --&gt; nilprint(type(type(X))) --&gt; string nil对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉 nil 作比较时应该加上双引号 123x = niltype(x) == nil --&gt; falsetype(x) == &quot;nil&quot; --&gt; true booleanLua 把 false 和 nil 看作是 false，其他都为 true，数字 0 也是 true 12345if 0 then print(&quot;数字 0 是 true&quot;)else print(&quot;数字 0 是 false&quot;)end --&gt; 数字 0 是 true numberLua 只有一种数字类型 number – doube（双精度）类型 string用 2 个方括号 “[[]]” 表示多行字符串 字符串连接使用的是两个点 .. 1print(985 .. 996) --&gt; 985996 用 # 表示字符串的长度，字母和符号占1个长度，汉字占3个长度 1print(#&quot;Q弹好味&quot;) --&gt; 10 table使用 {} 创建 1234-- 创建一个空表table1 = &#123;&#125;-- 直接初始化表table2 = &#123;&quot;牛&quot;, &quot;马&quot;&#125; Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。 12345678910a = &#123;&#125;a[&quot;key&quot;] = &quot;value&quot;key = 10a[key] = 22a[key] = a[key] + 11for k, v in pairs(a) do print(k .. &quot; : &quot; .. v)end--&gt; key : value--&gt; 10 : 33 Lua 表的索引从 1 开始 function123456789101112function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) endendprint(factorial1(5))factorial2 = factorial1print(factorial2(5))--&gt; 120--&gt; 120 thread在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 userdatauserdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 Lua 变量Lua 变量有三种类型：全局变量、局部变量、表中的域。 Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。 变量的默认值均为 nil 123456789101112131415161718a = 5 -- 全局变量local b = 5 -- 局部变量function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量endjoke()print(c,d) --&gt; 5 nildo local a = 6 -- 局部变量 b = 6 -- 对局部变量重新赋值 print(a,b); --&gt; 6 6endprint(a,b) --&gt; 5 6 应该尽可能的使用局部变量，有两个好处： 避免命名冲突。 访问局部变量的速度比全局变量更快。 赋值语句给多个变量同时赋值 1a, b = 10, &quot;西&quot; 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： 123x, y = &quot;左&quot;, &quot;右&quot;x, y = y, xprint(x .. y) --&gt; &quot;右&quot;&quot;左&quot; 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： 12a. 变量个数 &gt; 值的个数 按变量个数补足nilb. 变量个数 &lt; 值的个数 多余的值会被忽略 索引123t[i]t.i -- 当索引为字符串类型时的一种简化写法gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用 Lua 循环Lua 语言提供了以下几种循环处理方式： 循环类型 描述 while 循环 在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。 for 循环 重复执行指定语句，重复次数可在 for 语句中控制。 repeat…until 重复执行循环，直到 指定的条件为真时为止 循环嵌套 可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;） 循环控制语句 控制语句 描述 break 语句 退出当前循环或语句，并开始脚本执行紧接着的语句。 goto 语句 将程序的控制点转移到一个标签处。 goto Lua 语言中的 goto 语句允许将控制流程无条件地转到被标记的语句处。 语法格式如下所示： 1goto Label Label 的格式为： 1:: Label :: 以下实例在判断语句中使用 goto： 1234567local a = 1::label:: print(&quot;--- goto label ---&quot;)a = a+1if a &lt; 3 then goto label -- a 小于 3 的时候跳转到标签 labelend 输出结果为： 12--- goto label ------ goto label --- 从输出结果可以看出，多输出了一次 **— goto label —**。 以下实例演示了可以在 lable 中设置多个语句： 123456789i = 0::s1:: do print(i) i = i+1endif i&gt;3 then os.exit() -- i 大于 3 时退出endgoto s1 输出结果为： 12340123 有了 goto，我们可以实现 continue 的功能： 123456789for i=1, 3 do if i &lt;= 2 then print(i, &quot;yes continue&quot;) goto continue end print(i, &quot;no continue&quot;) ::continue:: print([[i&#x27;m end]])end 输出结果为： 1234561 yes continuei&#x27;m end2 yes continuei&#x27;m end3 no continuei&#x27;m end Lua 函数Lua 编程语言函数定义格式如下： 1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend optional_function_scope: 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name: 指定函数名称。 argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 123456789101112--[[ 函数返回两个值的最大值 --]]function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result;end-- 调用函数print(&quot;两值比较最大值为 &quot;,max(10,4)) ----&gt; 两值比较最大值为 10print(&quot;两值比较最大值为 &quot;,max(5,6)) ----&gt; 两值比较最大值为 6 多返回值 Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。 12s, e = string.find(&quot;www.runoob.com&quot;, &quot;runoob&quot;) print(s, e) --&gt; 5 10 Lua函数中，在return后列出要返回的值的列表即可返回多值，如 12345678910111213function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendprint(maximum(&#123;8,10,23,12,5&#125;)) --&gt; 23 3 可变参数 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数。 12345678910111213function average(...) result = 0 local arg=&#123;...&#125; --&gt; arg 为一个表，局部变量 for i,v in ipairs(arg) do result = result + v end print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;) return result/#argendprint(&quot;平均值为&quot;,average(10,5,3,4,5,6))--&gt; 总共传入 6 个数--&gt; 平均值为 5.5 有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前 12345678function fwrite(fmt, ...) ---&gt; 固定的参数fmt return io.write(string.format(fmt, ...)) endfwrite(&quot;runoob &quot;) ---&gt;fmt = &quot;runoob&quot;, 没有变长参数。 fwrite(&quot;%d%d &quot;, 1, 2) ---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2--&gt; runoob--&gt; 12 通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(‘#’, …) 或者 select(n, …) select(‘#’, …) 返回可变参数的长度。 select(n, …) 用于返回从起点 n 开始到结束位置的所有参数列表。 调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 n 开始到结束位置的所有参数列表，否则只能为字符串 **#**，这样 select 返回变长参数的总数。 123456789function f(...) a = select(3,...) --&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数 print (a) print (select(3,...)) --&gt;打印所有列表参数endf(0,1,2,3,4,5)--&gt; 2--&gt; 2 3 4 5 Lua 运算符算数运算符下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20： 操作符 描述 实例 + 加法 A + B 输出结果 30 - 减法 A - B 输出结果 -10 * 乘法 A * B 输出结果 200 &#x2F; 除法 B &#x2F; A 输出结果 2 % 取余 B % A 输出结果 0 ^ 乘幂 A^2 输出结果 100 - 负号 -A 输出结果 -10 &#x2F;&#x2F; 整除运算符(&gt;&#x3D;lua5.3) 5&#x2F;&#x2F;2 输出结果 2 关系运算符下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20： 操作符 描述 实例 &#x3D;&#x3D; 等于，检测两个值是否相等，相等返回 true，否则返回 false (A &#x3D;&#x3D; B) 为 false。 ~&#x3D; 不等于，检测两个值是否相等，不相等返回 true，否则返回 false (A ~&#x3D; B) 为 true。 &gt; 大于，如果左边的值大于右边的值，返回 true，否则返回 false (A &gt; B) 为 false。 &lt; 小于，如果左边的值大于右边的值，返回 false，否则返回 true (A &lt; B) 为 true。 &gt;&#x3D; 大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false (A &gt;&#x3D; B) 返回 false。 &lt;&#x3D; 小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false (A &lt;&#x3D; B) 返回 true。 逻辑运算符下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false： 操作符 描述 实例 and 逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。 (A and B) 为 false。 or 逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。 (A or B) 为 true。 not 逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。 not(A and B) 为 true。 其他运算符下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符： 操作符 描述 实例 .. 连接两个字符串 a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。 # 一元运算符，返回字符串或表的长度。 #”Hello” 返回 5 Lua 字符串 单引号间的一串字符。 12local str1 = &#x27;This is a string.&#x27;local str2 = &quot;This is also a string.&quot; 双引号间的一串字符。 123local str = &quot;Hello, &quot;str = str .. &quot;World!&quot; -- 创建一个新的字符串并将其赋值给strprint(str) -- 输出 &quot;Hello, World!&quot; [[ 与 ]] 间的一串字符。 1234567local multilineString = [[This is a multiline string.It can contain multiple lines of text.No need for escape characters.]]print(multilineString) 字符串长度计算在 Lua 中，要计算字符串的长度（即字符串中字符的个数），你可以使用 string.len函数或 utf8.len 函数，包含中文的一般用 utf8.len，string.len 函数用于计算只包含 ASCII 字符串的长度。 123456789local myString = &quot;Hello, 世界!&quot;-- 计算字符串的长度（字符个数）local length1 = utf8.len(myString)print(length1) --&gt; 输出 10-- string.len 函数会导致结果不准确（中文算3个字符）local length2 = string.len(myString)print(length2) --&gt; 输出 14 转义字符转义字符用于表示不能直接显示的字符，比如后退键，回车键等，如在字符串转换双引号可以使用 ****。 所有的转义字符和所对应的意义： 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符”\\“ 092 \\‘ 代表一个单引号（撇号）字符 039 \\“ 代表一个双引号字符 034 \\0 空字符(NULL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 1到2位十六进制所代表的任意字符 二位十六进制 字符串操作Lua 提供了很多的方法来支持字符串的操作： 序号 方法 &amp; 用途 1 string.upper(argument): 字符串全部转为大写字母。 2 string.lower(argument): 字符串全部转为小写字母。 3 string.gsub(mainString,findString,replaceString,num): 在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：&gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3); zzza 3 4 string.find (str, substr, [init, [plain]]): 在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。init 指定了搜索的起始位置，默认为 1，可以一个负数，表示从后往前数的字符个数。plain 表示是否使用简单模式，默认为 false，true 只做简单的查找子串的操作，false 表示使用使用正则模式匹配。以下实例查找字符串 “Lua” 的起始索引和结束索引位置：&gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1) 7 9 5 string.reverse(arg): 字符串反转&gt; string.reverse(&quot;Lua&quot;) auL 6 string.format(…): 返回一个类似printf的格式化字符串&gt; string.format(&quot;the value is:%d&quot;,4) the value is:4 7 string.char(arg) 和 string.byte(arg[,int]): char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。&gt; string.char(97,98,99,100) abcd &gt; string.byte(&quot;ABCD&quot;,4) 68 &gt; string.byte(&quot;ABCD&quot;) 65 &gt; 8 string.len(arg): 计算字符串长度。string.len(&quot;abc&quot;) 3 9 string.rep(string, n): 返回字符串string的n个拷贝&gt; string.rep(&quot;abcd&quot;,2) abcdabcd 10 .. 链接两个字符串&gt; print(&quot;www.runoob.&quot;..&quot;com&quot;) www.runoob.com 11 string.gmatch(str, pattern): 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。&gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end Hello Lua user 12 string.match(str, pattern, init): string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。&gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;) 2 questions &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;)) 2, &quot;questions&quot; 字符串截取 1string.sub(s, i [, j]) s: 要截取的字符串 i: 截取开始位置 j: 结束位置，默认为 -1，最后一个字符 字符串格式化 Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。 由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。 以下实例演示了如何对字符串进行格式化操作： 格式字符串可能包含以下的转义码: %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符 %d, %i - 接受一个数字并将其转化为有符号的整数格式 %o - 接受一个数字并将其转化为八进制数格式 %u - 接受一个数字并将其转化为无符号整数格式 %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母 %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母 %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E %f - 接受一个数字并将其转化为浮点数格式 %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式 %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式 %s - 接受一个字符串并按照给定的参数格式化该字符串 为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入: (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号. (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格. (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐. (4) 宽度数值 (5) 小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位. 1234567891011121314string1 = &quot;Lua&quot;string2 = &quot;Tutorial&quot;number1 = 10number2 = 20-- 基本字符串格式化print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))--&gt; Lua Tutorial-- 日期格式化date = 30; month = 8; year = 2023print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))--&gt; 02/01/2023-- 十进制格式化print(string.format(&quot;%.4f&quot;,1/3))--&gt; 0.3333 字符与整数相互转换 以下实例演示了字符与整数相互转换： 1234567891011121314-- 字符转换-- 转换第一个字符print(string.byte(&quot;Lua&quot;)) --&gt; 76-- 转换第三个字符print(string.byte(&quot;Lua&quot;,3)) --&gt; 97-- 转换末尾第一个字符print(string.byte(&quot;Lua&quot;,-1)) --&gt; 97-- 第二个字符print(string.byte(&quot;Lua&quot;,2)) --&gt; 117-- 转换末尾第二个字符print(string.byte(&quot;Lua&quot;,-2)) --&gt; 117-- 整数 ASCII 码转换为字符print(string.char(97)) --&gt; a 匹配模式 Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。 你还可以在模式串中使用字符类。 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 %d 匹配任意数字。所以你可以使用模式串 %d%d&#x2F;%d%d&#x2F;%d%d%d%d 搜索 dd&#x2F;mm&#x2F;yyyy 格式的日期： 123s = &quot;Deadline is 30/05/1999, firm&quot;date = &quot;%d%d/%d%d/%d%d%d%d&quot;print(string.sub(s, string.find(s, date))) *--&gt; 30/05/1999* 下面的表列出了Lua支持的所有字符类： 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对 .(点): 与任何字符配对 %a: 与任何字母配对 %c: 与任何控制符配对(例如 ) %d: 与任何数字配对 %l: 与任何小写字母配对 %p: 与任何标点(punctuation)配对 %s: 与空白字符配对 %u: 与任何大写字母配对 %w: 与任何字母&#x2F;数字配对 %x: 与任何十六进制数配对 %z: 与任何代表0的字符配对 %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对 [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母&#x2F;数字, 或下划线符号(_)配对 [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符: 12&gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))hello..up.down. 4 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下： 1( ) . % + - * ? [ ^ $ ‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%’不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。 模式条目可以是： 单个字符类匹配该类别中任意单个字符； 单个字符类跟一个 ‘*‘， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘+‘， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘-‘， 将匹配零或更多个该类的字符。 和 ‘*‘ 不同， 这个条目总是匹配尽可能短的串； 单个字符类跟一个 ‘?‘， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个； %*n*， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。 %b*xy*， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。 %f[*set*]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘\\0‘ 一样。 模式： 模式 指一个模式条目的序列。 在模式最前面加上符号 ‘^‘ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘$‘ 将使匹配过程锚定到字符串的结尾。 如果 ‘^‘ 和 ‘$‘ 出现在其它位置，它们均没有特殊含义，只表示自身。 捕获： 模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “.“ 匹配到的字符是 2 号捕获物， 匹配到 “%s*“ 的那部分是 3 号。 作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 &quot;()aa()&quot; 作用到字符串 &quot;flaaap&quot; 上，将产生两个捕获物： 3 和 5 。 Lua 数组","tags":["Lua"]},{"title":"Unity3D手游开发中的特殊文件夹","path":"/2023/08/29/Unity3D手游开发中的特殊文件夹/","content":"z 这里列举出手游开发中用到的所有特殊文件夹 EditorEditor文件夹可以在根目录下，也可以在子目录里，只要名子叫Editor就可以。比如目录：&#x2F;xxx&#x2F;xxx&#x2F;Editor 和 &#x2F;Editor 是一样的，无论多少个叫Editor的文件夹都可以。Editor下面放的所有资源文件或者脚本文件都不会被打进发布包中，并且脚本也只能在编辑时使用。一般呢会把一些工具类的脚本放在这里，或者是一些编辑时用的DLL。 比如我们现在要做类似技能编辑器，那么编辑器的代码放在这里是再好不过了，因为实际运行时我们只需要编辑器生成的文件，而不需要编辑器的核心代码。 Editor Default ResourcesEditor Default Resources注意中间是有空格的，它必须放在Project视图的根目录下，如果你想放在&#x2F;xxx&#x2F;xxx&#x2F;Editor Default Resources 这样是不行的。你可以把编辑器用到的一些资源放在这里，比如图片、文本文件、等等。它和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用。你可以直接通过EditorGUIUtility.Load去读取该文件夹下的资源。 12TextAsset test = EditorGUIUtility.Load(&quot;test.txt&quot;) as TestAsset;Debug.Log(Text.text); Gizmos我觉得这个文件夹其实没什么用处，如下代码所示它可以在Scene视图里给某个坐标绘制一个icon。它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名子，当然这个图片必须放在Gizmos文件夹下面。 1234void OnDrawGizmos()&#123; Gizmos.DrawIcon(transform.position, &quot;0.png&quot;, true);&#125; 如果只想挂在谋和游戏对象身上，那么在Inspector里面就可以直接设置。 这里还是要说说OnDrawGizmos()方法，只要脚本继承了MonoBehaviour后，并且在编辑模式下就会每一帧都执行它。发布的游戏肯定就不会执行了，它只能用于在scene视图中绘制一些小物件。比如要做摄像机轨迹，那么肯定是要在Scene视图中做一个预览的线，那么用Gizmos.DrawLine 和Gizmos.DrawFrustum就再好不过了。 Plugins如果做手机游戏开发一般Android或者ios要接入一些sdk，可以把sdk依赖的库文件放在这里， 比如 .so .jar .a文件，这样打完包以后就会自动把这些文件打在你的包中。 Resources 可以在根目录下，也可以在子目录里，只要名子叫Resources就可以。比如目录：&#x2F;xxx&#x2F;xxx&#x2F;Resources 和 &#x2F;Resources 是一样的，无论多少个叫Resources的文件夹都可以。Resources文件夹下的资源不管你用还是不用都会被打包进.apk或者.ipa Resource.Load ：编辑时和运行时都可以通过Resource.Load来直接读取。 Resources.LoadAssetAtPath() ：它可以读取Assets目录下的任意文件夹下的资源，它可以在编辑时或者编辑器运行时用，它但是它不能在真机上用，它的路径是”Assets&#x2F;xx&#x2F;xx.xxx” 必须是这种路径，并且要带文件的后缀名。 AssetDatabase.LoadAssetAtPath()：它可以读取Assets目录下的任意文件夹下的资源，它只能在编辑时用。它的路径是”Assets&#x2F;xx&#x2F;xx.xxx” 必须是这种路径，并且要带文件的后缀名。 我觉得在电脑上开发的时候尽量来用Resource.Load() 或者 Resources.LoadAssetAtPath() ，假如手机上选择一部分资源要打assetbundle，一部分资源Resource.Load().那么在做.apk或者.ipa的时候 现在都是用脚本来自动化打包，在打包之前 可以用AssetDatabase.MoveAsset()把已经打包成assetbundle的原始文件从Resources文件夹下移动出去在打包，这样打出来的运行包就不会包行多余的文件了。打完包以后再把移动出去的文件夹移动回来。 StreamingAssets这个文件夹下的资源也会全都打包在.apk或者.ipa 它和Resources的区别是，Resources会压缩文件，但是它不会压缩原封不动的打包进去。并且它是一个只读的文件夹，就是程序运行时只能读 不能写。它在各个平台下的路径是不同的，不过你可以用Application.streamingAssetsPath 它会根据当前的平台选择对应的路径。 有些游戏为了让所有的资源全部使用assetbundle，会把一些初始的assetbundle放在StreamingAssets目录下，运行程序的时候在把这些assetbundle拷贝在Application.persistentDataPath目录下，如果这些assetbundle有更新的话，那么下载到新的assetbundle在把Application.persistentDataPath目录下原有的覆盖掉。 因为Application.persistentDataPath目录是应用程序的沙盒目录，所以打包之前是没有这个目录的，直到应用程序在手机上安装完毕才有这个目录。 StreamingAssets目录下的资源都是不压缩的，所以它比较大会占空间，比如你的应用装在手机上会占用100M的容量，那么你又在StreamingAssets放了一个100M的assetbundle，那么此时在装在手机上就会在200M的容量。 转载自Unity3D研究院之手游开发中所有特殊的文件夹 | 雨松MOMO程序研究院 (xuanyusong.com)","tags":["Unity","手游"]},{"title":"迭代器和协程","path":"/2023/08/27/迭代器和协程/","content":"Unity 里的协程提供了一种异步处理的方式，可以用于实现延迟或者分帧的操作。 Unity 协程的实现基本原理是利用了迭代器。 本文目的：了解迭代器（IEnumerator）和可被迭代接口（IEnumerable） 迭代器可以顺序遍历取得一个容器内部的数据，所有实现了接口的 IEnumerable 的 IEnumerator方法的类都可以被迭代（可以用 foreach 遍历）。 迭代器在 List、Map 等容器内经常被使用，一个迭代器基本需要实现三个功能： ​\tHasNext：查询是否还有下一个元素 ​\tMoveNext：将指针移动到下一个元素 ​\tGetCurrent：获得当前迭代器指向的元素 利用迭代器进行元素遍历的时候，就是不断调用MoveNext和GetCurrent获取所有元素，利用HasNext确定终止条件。 在Unity中的迭代器接口形式为 1234567public interface IEnumerator&#123; object Current &#123; get; &#125; bool MoveNext(); void Reset();&#125; 其中MoveNext()既作为移动指针的作用，又实现了判断是否存在下一个元素的作用。Reset()方法给予了迭代器返回到初始态的能力。 现在实现一个自定义的迭代器 123456789101112131415161718192021222324252627282930313233public class MyEnumerator : IEnumerator&#123; List&lt;int&gt; list; int currentIndex; public MyEnumerator() &#123; list = new List&lt;int&gt;() &#123; 1, 2, 3, 4, 5, 6 &#125;; currentIndex = -1; &#125; public object Current &#123; get =&gt; list[currentIndex]; &#125; public bool MoveNext() &#123; if (currentIndex &lt; list.Count - 1) &#123; currentIndex++; Console.WriteLine($&quot;Ready to Get data from Index &#123;currentIndex&#125;&quot;); return true; &#125; else &#123; Console.WriteLine(&quot;No next data&quot;); return false; &#125; &#125; public void Reset() &#123; currentIndex = -1; &#125;&#125; 测试 12345MyEnumerator myEnumerator = new MyEnumerator();while (myEnumerator.MoveNext())&#123; Console.WriteLine(myEnumerator.Current);&#125; 结果 每次调用MoveNext的时候都会打印一条信息，并在确定成功移动指针的时候，打印当前值。 在没有下一个元素的时候，MoveNext返回 false，循环终止 注意：迭代器会先调用MoveNext方法，在取值，所以初始化的时候currentIndex应带设置成 -1 简单的分帧程序进入Unity 上文中MoveNext的调用是作为while循环的条件语句，利用while循环是心啊迭代器的遍历。如果将MoveNext的调用改到Update函数中，那么迭代器的遍历就能够在多帧内完成 123456789101112131415161718192021public class EnumeratorText : MonoBehaviour&#123; MyEnumerator myEnumerator; void Start() &#123; while (myEnumerator.MoveNext()) &#123; Debug.Log(myEnumerator.Current); &#125; &#125; private void Update() &#123; if (myEnumerator.MoveNext()) &#123; Debug.Log(&quot;Frame: &quot; + Time.frameCount); object current = myEnumerator.Current; Debug.Log(current.ToString()); &#125; &#125;&#125; 结果 元素1和元素2在不同的两帧内被打印出来，在遍历结束后，再调用MoveNext就只能得到 “No next data “ 的日志了。 作为协程，更需要的是分帧执行代码，而非迭代器中的元素，因此Current返回的值并不是很重要，重要的是MoveNext方法能够将指针移动到下一段需要执行的代码。现在将自定义迭代器中原先的 List list 字段改为List&lt;System.Action&gt; actions字段，并重新实现MoveNext和Current接口 12345678910111213141516171819202122232425262728293031323334353637public class MyEnumerator : IEnumerator&#123; List&lt;System.Action&gt; actions; int currentIndex; public MyEnumerator() &#123; actions = new List&lt;System.Action&gt;(); actions.Add(() =&gt; Debug.Log(&quot;Invoke at first frame.&quot;)); actions.Add(() =&gt; Debug.Log(&quot;Invoke at second frame.&quot;)); actions.Add(() =&gt; Debug.Log(&quot;Invoke at third frame&quot;)); currentIndex = -1; &#125; public object Current &#123; get =&gt; null; &#125; public bool MoveNext() &#123; if (currentIndex &lt; actions.Count) &#123; currentIndex++; actions[currentIndex].Invoke(); return true; &#125; else &#123; Debug.Log(&quot;finish&quot;); return false; &#125; &#125; public void Reset() &#123; currentIndex = -1; &#125;&#125; 测试 1234567891011121314public class EnumeratorText : MonoBehaviour&#123; MyEnumerator myEnumerator; void Start() &#123; myEnumerator = new MyEnumerator(); &#125; private void Update() &#123; Debug.Log(&quot;Frame: &quot; + Time.frameCount); myEnumerator.MoveNext(); &#125;&#125; 结果 这样，自定义的迭代器就有了存储操作的能力了，代码运行后分帧执行actions列表中的内容 Unity 协程Unity 协程基本利用了迭代器的这种特性，在每一帧中调用迭代器的MoveNext方法，利用MoveNext执行相应代码并移动指针指向下一个需要执行的代码块。当返回值为false的时候，说明迭代器到了尽头，就可以结束调用。而C#提供了 yield return 关键字用于快速实现迭代器，不需要很麻烦的自己再去实现 1234567891011121314151617private IEnumerator CoroutineFunction()&#123; Debug.Log(&quot;Start!&quot;); yield return 0; Debug.Log(&quot;Ready Count!&quot;); for(int i = 0; i &lt; 2; ++i) &#123; yield return i; &#125; yield return &quot;End Success&quot;; Debug.Log(&quot;The Last.&quot;);&#125; 两个 yield return 之间的代码就是MoveNext执行的内容，yield return 后的值就是Current返回的内容。 执行到最后 “The Last.” 代码之后没有了 yield return 语句，则返回false代表迭代器到了终点。这就是协程函数。 调用 1StartCoroutine(CoroutineFunction()); 运行","tags":["Unity","learn","协程","迭代器"]},{"title":"我第一个学会的设计模式：单例模式","path":"/2023/07/28/我第一个学会的设计模式：单例模式/","content":"首次接触在跟随@阿严Gaming老师的横板卷轴飞机大战教程中，第一季接触到了单例模式，虽然不太明白实现的原理，但是感觉很好用，后来也经常在自己的个人项目中用到。 单例模式的特点​\t1.单例类只能有一个实例。 ​\t2.单例类必须自己创建自己的唯一实例。 ​\t3.单例类必须给所有其他对象提供这一实例。 Unity中的单例就是整个场景中有且只有一个的组件：Audio Manager、Game Manager、Scene Loader、UI Manager、记录玩家数据的容器、记录游戏数据的容器等 使用单例模式可以有效防止不同步问题的出现，也可以避免频繁创建对象，节约内存 泛型单例12345678910public class Singleton&lt;T&gt;:MonoBehaviour where T : Component&#123; // 静态属性可全局访问 public static T Instance &#123;get; private set;&#125; // 创建实例 protected virtual void Awake() &#123; Instance = this as T; &#125; &#125; 持久泛型单例1234567891011121314151617public class PersistentSingleton&lt;T&gt; : MonoBehaviour where T : Component&#123; public static T Instance &#123;get ; private set;&#125; protected virtual void Awake() &#123; // 创建时判断是否已经存在此单例，如果存在就销毁正在创建的 if(Instance == null) &#123; Instance = this as T; &#125; else if(Instance != this) &#123; Destroy(gameObject); &#125; DontDestroyOnLoad(gameObject); &#125; 应用实例：这是一段挂载在“Audio Manager”物体上的代码，同时该物体上还挂载有Audio Source组件 AudioManager.cs：1234567891011public class AudioManager : Singleton&lt;AudioManager&gt;&#123; public AudioSource musicPlayer; public void ChangeMusic(AudioClip newClip) &#123; musicPlayer.Stop(); musicPlayer.clip = newClip; musicPlayer.Play(); &#125;&#125; 类中有一个公开的“ChangeMusic”方法，接受一个“AudioClip”类型的参数，用来将正在播放的音乐切换成传入的音频片段 使用方法如下： 1AudioManager.Instance.ChangeMusic(newClip); 简单好用！ 扩展经过网上的搜索，我发现一些传统的单例写法和视频老师教的并不一样，视频老师教的是以继承的方法使用，而下面的是以创建的方法使用：（以我现在的水平，学会一种已经暂时够用了，下面的仅仅是复制粘贴 : D） 实现思路不管什么语言，单例都可以用以下方法实现： 将构造方法私有化，使其不能再类的外部通过new关键字实例化该对象 在该类内部产生一个尾翼的实例化对象，并且将其封装为private static类型 定义一个静态方法返回这个唯一对象 同时单例模式又分为“懒汉”模式和“饿汉”模式 ​\t”懒汉“模式：这个类很懒，只会在你用到它的时候创建自己的实例 ​\t“饿汉”模式：这个类很勤快，不论你用不用，它都会自动创建自己的实例 懒汉模式描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉模式描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 还有具体的分类线程安全线程不安全的，我现在的水平有点理解不了 2023.8.15 19 : 15 更新 发现一篇解答了我之前疑问的博客，转载一波 Unity单例模式写法_unity 单例模式_Eraseris的博客-CSDN博客 单例一：最简单最常用的写法 A — 继承于MonoBehaviour12345678public class Singleton : MonoBehaviour&#123; public static Singleton instance; private void Awake() &#123; instance = this; &#125;&#125; 在另一个类中调用，Singleton.instance.(方法)。 单例二：升级版单例方法 B — 继承于MonoBehaviour这个方法，我总是可以在别人的项目里看见，后来才知道这比第一种规范。 1234567891011121314151617public class Singleton : MonoBehaviour&#123; public static Singleton instance; public static Singleton Instance &#123; get &#123; if (instance==null) &#123; instance = FindObjectOfType(typeof(Singleton)) as Singleton; //或者 instance=new GameObject(&quot;[Singleton]&quot;).AddComponent&lt;Singleton&gt;(); &#125; return instance; &#125; &#125;&#125; 在另一个类中调用，Singleton.instance.(方法)。 单例三：单例方法 C — 不继承于MonoBehaviour我还碰见一些单例是没有继承的，也就是没有挂在到物体身上的 123456789101112131415public class Singleton &#123; public static Singleton instance; public static Singleton Instance &#123; get &#123; if (instance==null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;&#125; 在另一个类中调用，Singleton.instance.(方法)。 总结：上述的单例方法中，我们可以进行归纳。其实就是继承和不继承 MonoBehaviour 的单例方法，接下来我们将用到C#语言面向对象的特点（封装、继承、多态），对我们的单例进行一个更好的规范。 还有两种写法，不过我目前是没碰到，我也转载过来了，有兴趣的可以往下看。在这里插入图片描述 在这里插入图片描述 单例五：最终版E — 不继承于MonoBehaviour（不随着场景切换而销毁）在这里插入图片描述","tags":["Unity","设计模式","单例模式"]},{"title":"Unity进阶：ScriptableObject使用指南","path":"/2023/07/28/Unity进阶：ScriptableObject使用指南/","content":"前言在游戏开发过程中，我们会经常与数据打交道。很多时候，我们会为游戏对象配置数据，比如玩家初始生命值、技能伤害等。那么就需要有个能够存储数据的东西来和游戏对象进行交互。 假设现在要做一个“打飞机”的游戏，玩家操控的飞机在吃了不同道具后会发射不同类型的子弹，这些子弹的飞行速度和伤害各不相同。那么显然我们要为每一种子弹配置好它的属性值。 实现方式有很多，比如我为每种子弹创建预制体，然后写脚本去定义代表子弹各个属性的成员变量，在那脚本挂载到子弹预制体上。为了方便在开发调试我们可以将这些变量声明为public，以便我们在编辑器面板中对数据进行改动。","tags":["Unity"]},{"title":"Unity小案例：“跳一跳”小游戏的简单实现","path":"/2023/06/12/Unity小案例：“跳一跳”小游戏的简单实现/","content":"从这篇开始，我要把一些做过的unity小案例搬到这上面来^_^ 一个模仿微信跳一跳小游戏的案例，（其实是学姐偷懒找我帮做的结课作业） 点击查看详细内容 展开的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UIElements;public class PlayerControl : MonoBehaviour&#123; Rigidbody rb; float timer; public float maxChargeTime; public float jumpPower; public bool doJump; public bool isGround; void Start() &#123; rb = GetComponent&lt;Rigidbody&gt;(); &#125; void Update() &#123; if (Input.GetKey(KeyCode.Mouse0) &amp;&amp; timer &lt; maxChargeTime) &#123; timer += Time.deltaTime; transform.localScale = new Vector3(1, 0.5f + (maxChargeTime - timer) / (2 * maxChargeTime), 1); &#125; if (Input.GetKeyUp(KeyCode.Mouse0)) &#123; doJump = true; transform.localScale = Vector3.one; &#125; if(transform.position.y&lt;-0.5f) &#123; GameManage.S.gameOver = true; &#125; &#125; void FixedUpdate() &#123; if (doJump &amp;&amp; isGround) &#123; Jump(); doJump = false; isGround = false; timer = 0; &#125; &#125; void Jump() &#123; Vector3 dir; if (GameManage.S.playerIsFacingYAxis) &#123; dir = transform.forward; &#125; else &#123; dir = -transform.right; &#125; dir.y = 1; rb.velocity = dir * timer * jumpPower; &#125; void OnCollisionEnter(Collision collision) &#123; if (collision.gameObject.CompareTag(&quot;Ground&quot;)) &#123; if (collision.contacts[0].normal == Vector3.up) &#123; isGround = true; GameManage.S.HitGround(transform.position); &#125; &#125; &#125;&#125; 完整代码：PlayerControl.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UIElements;public class PlayerControl : MonoBehaviour&#123; Rigidbody rb; float timer; public float maxChargeTime; public float jumpPower; public bool doJump; public bool isGround; void Start() &#123; rb = GetComponent&lt;Rigidbody&gt;(); &#125; void Update() &#123; if (Input.GetKey(KeyCode.Mouse0) &amp;&amp; timer &lt; maxChargeTime) &#123; timer += Time.deltaTime; transform.localScale = new Vector3(1, 0.5f + (maxChargeTime - timer) / (2 * maxChargeTime), 1); &#125; if (Input.GetKeyUp(KeyCode.Mouse0)) &#123; doJump = true; transform.localScale = Vector3.one; &#125; if(transform.position.y&lt;-0.5f) &#123; GameManage.S.gameOver = true; &#125; &#125; void FixedUpdate() &#123; if (doJump &amp;&amp; isGround) &#123; Jump(); doJump = false; isGround = false; timer = 0; &#125; &#125; void Jump() &#123; Vector3 dir; if (GameManage.S.playerIsFacingYAxis) &#123; dir = transform.forward; &#125; else &#123; dir = -transform.right; &#125; dir.y = 1; rb.velocity = dir * timer * jumpPower; &#125; void OnCollisionEnter(Collision collision) &#123; if (collision.gameObject.CompareTag(&quot;Ground&quot;)) &#123; if (collision.contacts[0].normal == Vector3.up) &#123; isGround = true; GameManage.S.HitGround(transform.position); &#125; &#125; &#125;&#125;","tags":["Unity"]},{"title":"测试显示图片问题","path":"/2023/06/10/测试显示图片问题/","content":"hudieren 可算是显示了 但是预览还是不显示0.o 而且Typora里也不显示 （先这样吧能用就行，等以后好好回来学习） 十分感谢 Hexo 图片插入无法显示的问题 - 知乎 (zhihu.com) 与 HEXO插入图片（详细版） - 简书 (jianshu.com) 与 hexo博客如何插入图片 - 知乎 (zhihu.com) 三位大佬的教程！ 我的改动方法： 改动前 ↓ ↓ ↓ 改动后 2023.8.28 下午15 : 15 更新： 找到了一个更好用的方法： 图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 _config.yml 来生成。 打开项目根目录中的 _config.yml 文件，将 _config.yml文件中的配置项 post_asset_folder 设为 true 后，执行命令 hexo new “post_name”，在 source&#x2F;posts 中会生成文章 post_name.md 和同名文件夹 post_name。 将图片资源放在 post_name 文件夹中，文章就可以使用相对路径引用图片资源了。 但是使用这种引用方式，图片只能在文章中显示，但无法在首页中正常显示。 如果希望图片在文章和首页中同时显示，可以使用标签插件语法(推荐使用这种引用方法)。 1&#123;% asset_img image.jpg This is an image %&#125; 2022 Hexo 博客搭建和使用教程(Windows) - 知乎 (zhihu.com)","tags":["测试"]},{"title":"第一篇博客捏^_^","path":"/2023/06/10/第一篇博客捏/","content":"你好啊，我是Zaromeow 我还不会用Markdown呀&#x3D;&#x3D; 亮 &#x3D;&#x3D; 加粗 倾斜 好像主页的预览页面太长了 一直写一直有 1 2 3 4 5 等下去研究一下（当天：已经知道了，只要在需要缩略的地方写上&lt;!– more –&gt;就好了，或者在开头的Front-Matter里写上：description: 预览能看到的内容） 先去学习markdown语法去 ​ 话说这里面有小表情吗⊙(・◇・)？ 好像有时候更新不会及时同步 一级二级三级哈哈 试试图片 ! 1642005032081 好像显示不出来？ 想了一想还是在这里练习markdown语法吧（我是前端小白，只是略微知道一点html与css语法然而卵全不会用） 怎么改字体颜色呀 12345678&lt;font color=red&gt;我是红色&lt;/font&gt;&lt;font color=#008000&gt;我是绿色&lt;/font&gt;&lt;font color=yellow&gt;我是黄色&lt;/font&gt;&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;&lt;font color= #871F78&gt;我是紫色&lt;/font&gt;&lt;font color= #DCDCDC&gt;我是浅灰色&lt;/font&gt;&lt;font size=5&gt;我是尺寸&lt;/font&gt;&lt;font face=&quot;逐浪立楷&quot; color=green size=10&gt;我是逐浪立楷，绿色，尺寸为5&lt;/font&gt; 我是红色我是绿色我是黄色我是蓝色我是紫色我是浅灰色我是尺寸我是逐浪立楷，绿色，尺寸为5 空白行：&lt;br&gt; 你们有没有发现 夏天真的比冬天热很多 啥都不懂呀现在，网页的格式还有想要的功能都不会实现，先原谅一回吧 代码语法测试： 这是New Bing生成的一段代码： 你好，这是Bing。我可以尝试帮你写一段控制角色移动的C#代码。你可以参考以下代码，它使用了Rigidbody组件和Input类来获取用户的输入，并根据移动方向和速度更新角色的位置(https://stackoverflow.com/questions/67965706/unity-rigidbody)。你可以根据你的需求修改代码中的参数和逻辑。 1234567891011121314151617181920212223242526272829303132using UnityEngine;public class CharacterMovement : MonoBehaviour&#123; // 移动速度 public float speed = 5f; // 移动方向 private Vector3 direction; // 刚体组件 private Rigidbody rb; void Start() &#123; // 获取刚体组件 rb = GetComponent&lt;Rigidbody&gt;(); &#125; void Update() &#123; // 获取水平和垂直方向的输入 float horizontal = Input.GetAxis(&quot;Horizontal&quot;); float vertical = Input.GetAxis(&quot;Vertical&quot;); // 计算移动方向 direction = new Vector3(horizontal, 0, vertical).normalized; &#125; void FixedUpdate() &#123; // 根据移动方向和速度更新刚体的位置 rb.MovePosition(transform.position + direction * speed * Time.fixedDeltaTime); &#125;&#125; 2023&#x2F;6&#x2F;22 昨天把电脑整个重装了一遍系统，发现以前的博客用不了了 于是又照着下面教程装了一遍 换电脑后怎么迁移hexo博客？_hexo博客迁移_Ann’s Blog的博客-CSDN博客 Git教程 SSH keys配置_Ann’s Blog的博客-CSDN博客 下次就从这里开始写吧","tags":["欣喜若狂"]},{"title":"Hello World","path":"/2023/06/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"notes","path":"/notes/index.html","content":"我的笔记页面 研究了半天，笔记还是显示不出来。。。"},{"title":"C#关于值类型和引用类型在堆或栈中的存储","path":"/notes/Unity学习笔记/C#关于值类型和引用类型在堆或栈中的存储.html","content":"值类型和引用类型到底实在哪里存储的，堆？还是栈？ 首先值类型和引用类型，是C#中变量的两种类型。值类型包括我们常用的整型、浮点型、布尔型数值、枚举等。引用类型包括类、接口、数组、委托等。 至于堆和栈，是两种不同的内存区域，堆（heap），栈（即堆栈（stack））。 简单来说，值类型和引用类型变量本身在栈中分配内存，引用类型的实例在堆中分配内存。（要注意的是，一定要理解清楚引用类型变量本身和引用类型的实例的区别，引用类型变量好比一个指针，它所指向的内容即引用类型的实例）。有时候又会看到一些说法，值类型在其所定义的位置分配内存，这让人感到很混乱却也不得不在意，下面简单捋一下。 如下面代码： 12345678910public class TestClass &#123; int a = 0;&#125; public void Function()&#123; int b = 0; TestClass class1 = new TestClass();&#125; 方法 Function 中定义的值类型（整型b）在栈中分配，引用类型（类class1）以一个类似于指针的形式也存储于栈中，而类的实例对象即代码中class1所引用的实际数据（整型a）是在堆上面分配的。这就可以理解，为什么有的地方会说“值类型在其所定义的地方分配”，因为上述代码中的值类型a由于定义在类中，作为类的一个成员，在类实例化时是被分配到堆中的。 因此，更进一步地，可以理解为：值类型作为一个方法中的局部变量时，是在栈中分配的，而当作为类的成员变量时，是分配在堆中的。 在上面代码的 TestClass 中添加一个Run函数： 123456789101112131415public class TestClass &#123; int a = 0; public void Run() &#123; int c = 0; &#125;&#125; public void Function()&#123; int b = 0; TestClass class1 = new TestClass(); class1.Run();&#125; 此时，整型a是在堆中分配内存，而Run函数中的整型c在栈中分配内存。 因此关于值类型、引用类型各自在堆或栈上的内存分配可以总结为： 值类型作为方法中的局部变量时，在栈中分配，而作为类的成员变量时，在堆中分配；引用类型变量在栈中分配，引用类型的实例在堆中分配。 （梳理了一下自己的思路，对知识点的理解更清晰了，若有误还望指正啦。） C# 关于值类型和引用类型在堆或栈中的存储-CSDN博客"},{"title":"Unity学习笔记","path":"/notes/Unity学习笔记/index.html","content":"d 大撒大撒大苏打 unity"},{"title":"游戏","path":"/notes/游戏/index.html","content":"d 大撒大撒大苏打 unity"},{"title":"生活","path":"/notes/生活/index.html","content":"d 大撒大撒大苏打 unity"},{"path":"/custom/js/ZYDark.js","content":"/** * 监听系统主题 * @type {MediaQueryList} */ var OSTheme = window.matchMedia('(prefers-color-scheme: dark)'); OSTheme.addListener(e => { if (window.localStorage.getItem('ZYI_Theme_Mode') === 'Moss') { ThemeChange('Moss'); } }) /** * 修改博客主题 * @param theme 亮为light,暗为dark,自动为auto * @constructor */ const ThemeChange = (theme) => { if (theme === 'light' || (theme === 'Moss' && !OSTheme.matches)) { document.querySelector(\"html\").id = \"ZYLight\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(3)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").style.filter= 'grayscale(100%)'; } else { document.querySelector(\"html\").id = \"ZYDark\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(3)\").style.filter= 'grayscale(100%)'; } if (theme==='Moss'){document.querySelector(\"#start > aside > footer > div > a:nth-child(4)\").style.filter= 'grayscale(0%)';} else {document.querySelector(\"#start > aside > footer > div > a:nth-child(4)\").style.filter= 'grayscale(100%)';} window.localStorage.setItem('ZYI_Theme_Mode', theme); } /** * 初始化博客主题 */ switch (window.localStorage.getItem('ZYI_Theme_Mode')) { case 'light': ThemeChange('light'); break; case 'dark': ThemeChange('dark'); break; default: ThemeChange('dark'); } /** * 切换主题模式 */ document.querySelector(\"#start > aside > footer > div > a:nth-child(2)\").onclick = () => { ThemeChange('dark'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(3)\").onclick = () => { ThemeChange('light'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(4)\").onclick = () => { ThemeChange('Moss'); }"},{"path":"/custom/css/ZYDark.css","content":"#ZYDark:root { --site-bg: #1c1e21; --card: #373d43; --block: #26292c; --block-border: #383d42; --block-hover: #2f3337; --text-p0: #fff; --text-p1: #ccc; --text-p2: #b3b3b3; --text-p3: #858585; --text-p4: #707070; --text-meta: #4d4d4d; --text-code: #ff6333; } @media screen and (max-width: 667px) { #ZYDark:root { --site-bg: #000; } } #ZYDark:root { --blur-bg: rgba(0,0,0,0.5); } #ZYDark .float-panel { --blur-bg: rgba(0,0,0,0.4); } #ZYDark .tag-plugin.tag { --theme: #ff6333; --theme-bg1: #3d1e14; --theme-bg2: #2f2522; --theme-border: #5c2d1f; --text-p0: #ffc4b3; --text-p1: #dfae9f; --text-p2: #f1997e; } #ZYDark .tag-plugin[color='red'] { --theme: #f44336; --theme-bg1: #3d1714; --theme-bg2: #2f2322; --theme-border: #5c231f; --text-p0: #ffb8b3; --text-p1: #dfa49f; --text-p2: #f1867e; } #ZYDark .tag-plugin[color='orange'] { --theme: #fa6400; --theme-bg1: #3d2514; --theme-bg2: #2f2722; --theme-border: #5c371f; --text-p0: #ffd1b3; --text-p1: #dfb99f; --text-p2: #f1ac7e; } #ZYDark .tag-plugin[color='yellow'] { --theme: #ffbd2b; --theme-bg1: #3d3014; --theme-bg2: #2f2b22; --theme-border: #5c491f; --text-p0: #ffe7b3; --text-p1: #dfcb9f; --text-p2: #f1cd7e; } #ZYDark .tag-plugin[color='green'] { --theme: #3dc550; --theme-bg1: #143d1a; --theme-bg2: #222f24; --theme-border: #1f5c27; --text-p0: #b3ffbd; --text-p1: #9fdfa8; --text-p2: #7ef18e; } #ZYDark .tag-plugin[color='cyan'] { --theme: #1bcdfc; --theme-bg1: #14353d; --theme-bg2: #222d2f; --theme-border: #1f4f5c; --text-p0: #b3efff; --text-p1: #9fd2df; --text-p2: #7ed9f1; } #ZYDark .tag-plugin[color='blue'] { --theme: #2196f3; --theme-bg1: #142b3d; --theme-bg2: #222a2f; --theme-border: #1f415c; --text-p0: #b3ddff; --text-p1: #9fc3df; --text-p2: #7ebef1; } #ZYDark .tag-plugin[color='purple'] { --theme: #9c27b0; --theme-bg1: #37143d; --theme-bg2: #2d222f; --theme-border: #531f5c; --text-p0: #f4b3ff; --text-p1: #d69fdf; --text-p2: #e07ef1; } #ZYDark .tag-plugin[color='light'] { --theme-border: #fff; --theme-bg1: #e0e0e0; --theme-bg2: #fff; --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .tag-plugin[color='dark'] { --theme-border: #000; --theme-bg1: #1f1f1f; --theme-bg2: #111; --text-p0: #fff; --text-p1: #fff; --text-p2: #e0e0e0; --text-p3: #ddd; --text-code: #fff; } #ZYDark .tag-plugin[color='warning'], #ZYDark .tag-plugin[color='light'] { --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .social-wrap a.social:hover { box-shadow: none; } /* waline评论样式 */ #ZYDark .wl-count{ padding: .375em; font-weight: bold; font-size: 1.25em; color: #fff; } #ZYDark .cmt-body.waline{ --waline-white: #000; --waline-light-grey: #666; --waline-dark-grey: #999; /* 布局颜色 */ --waline-color: #fff; --waline-bgcolor: var(--block); --waline-bgcolor-light: #272727; --waline-border-color: #333; --waline-disable-bgcolor: #444; --waline-disable-color: #272727; /* 特殊颜色 */ --waline-bq-color: #272727; /* 其他颜色 */ --waline-info-bgcolor: #272727; --waline-info-color: #666; }"}]