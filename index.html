<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Unity小功能：随机播放列表中的歌曲" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/16/Unity%E5%B0%8F%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AD%8C%E6%9B%B2/" class="article-date">
  <time class="dt-published" datetime="2023-09-16T02:46:36.000Z" itemprop="datePublished">2023-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/16/Unity%E5%B0%8F%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AD%8C%E6%9B%B2/">Unity小功能：随机播放列表中的歌曲</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>核心思想为：记录暂时没有播放的歌曲，每次播放完毕后从中随机抽取一首进行播放，并将这首歌从未播放列表移除，所有歌曲都播放一遍后，填充未播放列表</strong></p>
<br />

<hr>
<p>首先准备几首歌，并存入歌曲数组</p>
<p><img src="/2.png"></p>
<br />

<p>声明一个整形变量，记录当前播放歌曲在数组中的下标，声明一个列表，记录暂时未播放歌曲的下标</p>
<p><img src="/3.png"></p>
<br />

<p>并对列表进行初始化</p>
<p><img src="/4.png"></p>
<br />

<p>随机从未播放列表中选取一个值，作为将要播放的歌曲，并从未播放列表中移除</p>
<p><img src="/5.png"></p>
<br />

<p>准备完毕，开始播放音乐，通过协程的 <strong>yield return new WaitForSeconds</strong> 模拟歌曲播放完毕切歌</p>
<p><img src="/6.png"></p>
<br />

<p>别忘了把准备好的歌拖进歌曲数组中</p>
<p><img src="/1.png"></p>
<hr>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">PersistentSingleton</span>&lt;<span class="title">AudioManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> AudioSource bGMPlayer;<span class="comment">// 获取播放器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioClip[] bGMClips;<span class="comment">// 歌曲音频数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> index;<span class="comment">// 正在播放的歌曲在数组中的位置</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; unPlayedIndex;<span class="comment">// 暂时未播放歌曲的index</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitiaList();</span><br><span class="line">        StartCoroutine(ChangeBGMCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化未播放歌曲列表，默认所有歌曲均未播放，列表填充满</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitiaList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        unPlayedIndex = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(bGMClips.Length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; unPlayedIndex.Capacity; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unPlayedIndex.Add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 随机选取未播放列表中的一个index值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeIndex</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (unPlayedIndex.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            InitiaList();</span><br><span class="line">        &#125;</span><br><span class="line">        index = unPlayedIndex[Random.Range(<span class="number">0</span>, unPlayedIndex.Count)];</span><br><span class="line">        <span class="comment">// 选取之后，从列表中移除当前index值</span></span><br><span class="line">        unPlayedIndex.Remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 切歌协程，歌曲播放完毕之后，随机选取一首歌继续播放</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">ChangeBGMCoroutine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bGMPlayer.Stop();</span><br><span class="line">            ChangeIndex();</span><br><span class="line">            bGMPlayer.clip = bGMClips[index];</span><br><span class="line">            bGMPlayer.Play();</span><br><span class="line">            <span class="comment">// 等待一段时间，该时间为歌曲长度，等待结束即为歌曲播放完毕</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">bGMPlayer.clip.length</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/16/Unity%E5%B0%8F%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AD%8C%E6%9B%B2/" data-id="clmtdoony0003egru5scm70ef" data-title="Unity小功能：随机播放列表中的歌曲" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E5%8A%9F%E8%83%BD/" rel="tag">小功能</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE/" rel="tag">随机播放</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity：UGUI基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/13/Unity%EF%BC%9AUGUI%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2023-09-13T10:02:38.000Z" itemprop="datePublished">2023-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/13/Unity%EF%BC%9AUGUI%E5%9F%BA%E7%A1%80/">Unity：UGUI基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Canvas与三种画布渲染模式"><a href="#Canvas与三种画布渲染模式" class="headerlink" title="Canvas与三种画布渲染模式"></a>Canvas与三种画布渲染模式</h2><h3 id="Canvas简介"><a href="#Canvas简介" class="headerlink" title="Canvas简介"></a>Canvas简介</h3><p>Canvas画布是承载所有UI元素的区域。Canvas实际上是一个挂载着Canvas组件的游戏对象。所有的UI元素都必须是Canvas的子对象。我们创建任何一个UI元素时，如果场景中没有Canvas画布，就会自动创建画布，并且将新元素置于其下。</p>
<h3 id="Canvas画布参数-RenderMode"><a href="#Canvas画布参数-RenderMode" class="headerlink" title="Canvas画布参数 RenderMode"></a>Canvas画布参数 RenderMode</h3><h4 id="Screen-Space-Overlay模式"><a href="#Screen-Space-Overlay模式" class="headerlink" title="Screen Space-Overlay模式"></a>Screen Space-Overlay模式</h4><p><strong>Screen Space-Overlay（屏幕空间-覆盖）</strong>的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕，如下图效果：</p>
<p><img src="/1.png"><img src="/2.png"><img src="/3.png"></p>
<p>（在此模式下，虽然在Canvas前放置了3D人物，但是在Game窗口中并不能观察到3D人物）</p>
<p>Screen Space-Overlay模式的画布有 <strong>Pixel Perfect</strong> 和 <strong>Sort Layer</strong> 两个参数：</p>
<p>　　（1）<strong>Pixel Perfect：</strong>只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。</p>
<p>　　（2）<strong>Sort Layer:</strong> Sort Layer是UGUI专用的设置，用来指示画布的深度。</p>
<h4 id="Screen-Space-Camera模式"><a href="#Screen-Space-Camera模式" class="headerlink" title="Screen Space-Camera模式"></a>Screen Space-Camera模式</h4><p>　　<strong>Screen Space-Camera（屏幕空间-摄影机模式）</strong>和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。</p>
<p>　　这种模式可以用来实现在UI上显示3D模型的需求，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求，效果如下图所示：</p>
<p><img src="/4.png"><img src="/5.png"></p>
<p>它比Screen Space-Overlay模式的画布多了下面几个参数：</p>
<p>　　（1）<strong>Render Camera：</strong>渲染摄像机</p>
<p>　　（2）<strong>Plane Distance：</strong>画布距离摄像机的距离</p>
<p>　　（3）<strong>Sorting Layer：</strong>Sorting Layer是UGUI专用的设置，用来指示画布的深度。可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。</p>
<p>　　　　可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</p>
<p>　　（4）Order in Layer:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。</p>
<h4 id="World-Space模式"><a href="#World-Space模式" class="headerlink" title="World Space模式"></a>World Space模式</h4><p>　　World Space即世界控件模式。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时， 　　可以使用这个模式。</p>
<p>　　它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</p>
<p>　　这种模式可以用来实现跟随人物移动的血条或者名称，如下图所示：</p>
<p><img src="/6.png"><img src="/7.png"></p>
<p>我们通过下面的表格可以对比一下三种渲染模式的区别：</p>
<table>
<thead>
<tr>
<th>渲染模式</th>
<th>画布对应屏幕</th>
<th>摄像机</th>
<th>像素对应</th>
<th>适合类型</th>
</tr>
</thead>
<tbody><tr>
<td>Screen Space-Overlay</td>
<td>是</td>
<td>不需要</td>
<td>可选</td>
<td>2D UI</td>
</tr>
<tr>
<td>Screen Space-Camera</td>
<td>是</td>
<td>需要</td>
<td>可选</td>
<td>2D UI</td>
</tr>
<tr>
<td>World Space</td>
<td>否</td>
<td>需要</td>
<td>不可选</td>
<td>3D UI</td>
</tr>
</tbody></table>
<hr>
<h2 id="使UI跟随屏幕分辨率变化自适应"><a href="#使UI跟随屏幕分辨率变化自适应" class="headerlink" title="使UI跟随屏幕分辨率变化自适应"></a>使UI跟随屏幕分辨率变化自适应</h2><h3 id="为什么需要UI自适应"><a href="#为什么需要UI自适应" class="headerlink" title="为什么需要UI自适应"></a>为什么需要UI自适应</h3><ul>
<li>场景1：手机需要再竖屏与横屏之间切换，这样适应竖屏的UI元素的位置，未必适应横屏</li>
<li>场景2：即使都采用横屏模式，手机的横纵比不同，有的是2140x1080，有的是2400x1080，有的是1920x1080，等等…</li>
<li>场景3：即使都采用相同横纵比，但屏幕分辨率不同，例如：1920x1080与2560x1440</li>
</ul>
<p><strong>Canvas Scaler 组件中的参数：UI Scale Mode</strong></p>
<h3 id="一、Constant-Pixel-Size"><a href="#一、Constant-Pixel-Size" class="headerlink" title="一、Constant Pixel Size"></a>一、Constant Pixel Size</h3><p>像素大小始终不变，即一个100<em>100的图片在任何的分辨率下都占用100</em>100的像素。简单比较好理解。Scale Factor是表示缩放倍数。比如是2时，即将上面图片整体是缩放两倍是不变形的。</p>
<h3 id="二、Scale-With-Screen-Size"><a href="#二、Scale-With-Screen-Size" class="headerlink" title="二、Scale With Screen Size"></a>二、Scale With Screen Size</h3><p>这种模式应用场景多一点。首先逐个说明下：</p>
<p>1）<strong>Reference Resolution</strong>是开发时的分辨率。以后缩放就参考它。</p>
<p>2）<strong>Screen Match Mode</strong>又包含三种模式</p>
<ul>
<li><p><strong>Match Width Or Height：</strong>下面包含一个Macht属性，当处于最左边时，屏幕高度对于UI大小完全没有任何影 响，只有宽度会对UI大小产生影响。假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference   Resolution设置参数的x倍。也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸 ，当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响 ，处于中间某处时，对上述两者的影响进行权重加成 。所以一般我们都把其放在0.5的位置（0.618也很舒服哦）。</p>
</li>
<li><p><strong>Expand 缩放不剪切：</strong>当屏幕分辨率与设定不同时，选择变化较小的一个方向（横向还是纵向），进行缩放显示，它会保证设计时分辨率能显示出来的缩放后依然能显示出来。</p>
</li>
<li><p><strong>Shrink 缩放剪切：</strong>当屏幕分辨率与设定不同时，选择变化较大的一个方向（横向还是纵向）进行缩放显示，对于超出的部分剪切不显示。</p>
</li>
</ul>
<h3 id="三、Constant-Physical-Size"><a href="#三、Constant-Physical-Size" class="headerlink" title="三、Constant Physical Size"></a>三、Constant Physical Size</h3><p>保持物理上不变的方式，这个应用场景较少，具体是这样的，比如你电脑分辨率是 1000<em>2000而你的手机分辨率也是1000</em>2000。虽然电脑屏幕比手机屏幕大的多，但是他们最后显示出来图片的物理大小是一样的。</p>
<hr>
<h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><p><strong>目标：</strong></p>
<p>角落的四个按钮在任何分辨率都能正常显示</p>
<p><strong>Hierarchy布局：</strong></p>
<p><img src="/9.png"></p>
<p><strong>Canvas组件设置：</strong></p>
<p><img src="/10.png"></p>
<p><strong>Image的Rect Transform组件设置：</strong></p>
<p><img src="/11.png"></p>
<p><strong>Button组件Rect Transform组件设置：</strong></p>
<p><img src="/12.png"></p>
<p><strong>效果展示：</strong></p>
<p>1920 x 1080：</p>
<p><img src="/13.png"></p>
<p>800 x 600：</p>
<p><img src="/14.png"></p>
<p>1080 x 1920：</p>
<p><img src="/15.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/13/Unity%EF%BC%9AUGUI%E5%9F%BA%E7%A1%80/" data-id="clmtdooo00008egru1u2a1fq7" data-title="Unity：UGUI基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多级渐远纹理Mipmap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/13/%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap/" class="article-date">
  <time class="dt-published" datetime="2023-09-13T08:27:48.000Z" itemprop="datePublished">2023-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/13/%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap/">多级渐远纹理Mipmap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p>MIP来源于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%89%E4%B8%81%E6%96%87/360796?fromModule=lemma_inlink">拉丁文</a>中的multum in parvo，意为在一个小空间里的多数。MIP map技术与<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE/7556421?fromModule=lemma_inlink">材质贴图</a>技术结合，根据距观看者远近距离的不同，以不同的分辨率将单一的材质贴图以多重图像的形式表现出来并代表平面纹理：尺寸最大的图像放在前面显著的位置，而相对较小的图像则后退到背景区域。每一个不同的尺寸等级定义成一个MIP map水平。MIP map技术帮助避免了不想要的锯齿边缘（称为锯齿状图形）在图像中出现，这种锯齿状图形可能是由于在不同分辨率下使用bit map图像产生的。</p>
<hr>
<h3 id="先了解纹理过滤"><a href="#先了解纹理过滤" class="headerlink" title="先了解纹理过滤"></a>先了解纹理过滤</h3><p>想要了解为什么要使用Mipmap，首先要知道纹理过滤是什么。</p>
<p>当你在玩吃鸡的时候可能会发现一个现象，一个人在距离你5米的地方，可以观察到敌人的一举一动，包括身上的装备等等，但当你拿到98k时，你会蹲在远处狙击别人，这时不开镜的你看500米远处的敌人只能看到一个黑点，这其中远近看到的区别就有应用到纹理过滤。</p>
<p>游戏中A物体的游戏设计纹理贴图是400*400Texel(纹理像素)</p>
<p>1.当你(摄像机)跟A物体的距离为0时，在你屏幕上显示的像素就是400*400，跟贴图的纹理像素大小相同，此时不需要做特殊处理</p>
<p>2.假设你离A物体10米远时,屏幕显示的pix为200<em>200,当200</em>200的像素要显示400<em>400纹理像素的物体时，此时的一颗像素需要映射2</em>2的纹理像素，这个时候就有个问题了，这颗像素要显示什么颜色？只能用合适的算法在这2*2里的纹理像素中计算得出，在这里引用OpenGL中的邻近过滤和线性过滤：</p>
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p>
<p><img src="/1.png" alt="临近过滤"></p>
<p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p>
<p><img src="/2.png" alt="线性过滤"></p>
<p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p>
<p><img src="/3.png"></p>
<hr>
<h3 id="当距离很远的时候怎么算"><a href="#当距离很远的时候怎么算" class="headerlink" title="当距离很远的时候怎么算"></a>当距离很远的时候怎么算</h3><p>此时的你来到远离市区500米的山上，想要狙击别人，你只能看到一个个很小的人影，在不开镜的情况下只能看到人的跑动。</p>
<p>此时敌人在屏幕显示为20<em>20，400</em>400的纹理像素映射在20<em>20的像素内，一颗像素需要映射20</em>20的纹理像素，如果直接进行纹理过滤，那么在使用线性过滤的情况下，只会使用纹理坐标映射点的周围4颗纹理像素进行计算，那么其他的396颗纹理像素就没了参考价值，考虑极端情况下，如果纹理坐标映射点在人的头发，那么不就只是显示黑色了？ ，那么在最终的显示效果上可能会产生锯齿或者摩尔纹，摩尔纹长这样：</p>
<p><img src="/4.jpg" alt="摩尔纹"></p>
<p>这视觉效果必须得改善，那我不能参考所有需要映射的纹理像素进行平均取色吗？可以，但是你的GPU允许你这么做吗，有兴趣可以做个实验，自己采样所有纹理像素进行纹理过滤，此时你如果远处的模型较多的情况下，</p>
<p>使用原生的线性过滤：60FPS，渲染一个物体每颗像素的颜色需要计算4个纹理像素的插值。</p>
<p>采样所有纹理像素进行纹理过滤：1FPS,渲染一个物体每颗像素的颜色需要采样计算400个纹理像素的插值。</p>
<p>可以想象性能换质量的消耗实在太大，在如今的GPU算力下是施行不了的.</p>
<p>那有办法不损耗算力，又可以提升显示质量吗？可以，使用Mipmap.</p>
<hr>
<h3 id="Mipmap概念"><a href="#Mipmap概念" class="headerlink" title="Mipmap概念"></a>Mipmap概念</h3><p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p>
<p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。</p>
<hr>
<h3 id="Mipmap效果"><a href="#Mipmap效果" class="headerlink" title="Mipmap效果"></a>Mipmap效果</h3><p><img src="/5.jpg" alt="Mipmap"></p>
<p>上图是Mipmap的纹理，在储存上最大的为mipmap0，mipmap1的分辨率为mipmap0的一半,以此一直创建下去，直到纹理为一个像素时停止，在某些引擎中可以设置Mipmap的强弱，也就是Mipmap的创建次数。但一般直接拉到最强，因为越到后面创建的大小越小，占用的内存也就越小。</p>
<p><img src="/6.gif" alt="Mipmap效果"></p>
<p><strong>不使用Mipmap：</strong><br>        在先前讲的1颗像素需要映射20<em>20的纹理像素时，显示效果失真，锯齿以及可能会产生摩尔纹，发生的原因是在纹理过滤时，一颗像素只采样了原本20</em>20纹理像素里2*2纹理像素的颜色进行线性插值，得到最终的颜色，其他的396颗纹理像素无用，浪费显存且取色不精确。</p>
<p><strong>使用Mipmap:</strong><br>Mipmap创建：预先创建原纹理大小2分之一的多级渐远纹理，在多级渐远纹理取色采样时，也会进行线性过滤，可以理解成预先创建每隔一定阈值(也就是每次映射像素为上一级别多级渐远纹理的2分之一的时候）并经过了线性过滤的纹理。</p>
<p>使用Mipmap的渲染过程：20<em>20的像素需要映射400</em>400的纹理像素时，检测到一颗像素需要映射到纹理像素为20<em>20，在Mipmap纹理中里寻找最接近20</em>20纹理像素的多级渐远纹理，并使用此多级渐远纹理进行采样。</p>
<p>此时采样用的多级渐远纹理的颜色也是从上一级的多级渐远纹理迭代采样插值计算而来，也就是一颗像素映射此多级渐远纹理间接插值计算了20<em>20的纹理像素的颜色，取色的效果当然比一颗像素直接映射原图20</em>20只采样了2*2的纹理像素颜色进行线性插值要好得多，使用Mipmap就避免了采样的纹理像素过少而失真，</p>
<p>理论上点对点的映射最为精确，而如果最邻近的子纹理跟20*20无法点对点采样映射，还可以设置多级渐远纹理的过滤方式</p>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINEAR</td>
<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody></table>
<hr>
<h3 id="Mipmap的优点与缺点"><a href="#Mipmap的优点与缺点" class="headerlink" title="Mipmap的优点与缺点"></a>Mipmap的优点与缺点</h3><p><strong>优点:</strong><br>1.质量高：避免了在远距离情况下的采样频率低和数据频率高造成的失真和摩尔纹，效果比无Mipmap好得多。</p>
<p>2.性能好：避免了不使用Mipmap下距离远时采样频率低和数据频率高而照成texture cache命中率不高(相邻Pixel采样Texel时uv相差比较大)使性能下降。</p>
<p><strong>缺点：</strong><br>1.占用显存，可使用ue的纹理流缓存优化（IO换显存）。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42428486/article/details/118856697">Mipmap详解(有无Mipmap区别、原理、优点、缺点、优化)_爱吃的板栗.的博客-CSDN博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/13/%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap/" data-id="clmtdooo2000cegruh5ogazsl" data-title="多级渐远纹理Mipmap" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mipmap/" rel="tag">Mipmap</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式：对象池系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T11:43:43.000Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%B3%BB%E7%BB%9F/">设计模式：对象池系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="想象一下"><a href="#想象一下" class="headerlink" title="想象一下"></a>想象一下</h4><p>我正在做一个丧尸围城小游戏，丧失源源不断袭来，而我的角色需要不停消灭它们，并升级武器应对更猛烈的攻击。</p>
<p>如何处理丧尸生成逻辑？初学者的我想到的第一个方法就是把丧失拖成预制体，<strong>Instantiate</strong> 它并设置一个随机位置，当它死亡时调用 <strong>Distory()</strong> 销毁游戏物体。但是当我把角色射出的子弹、枪口特效、丧失死亡掉落的经验特效都这样处理，随着游戏进行，我的电脑变得越来越卡。</p>
<p>这是因为游戏物体的频繁创建和销毁会占用大量内存空间，频繁调用GC占用大量性能。怎么处理呢？</p>
<h4 id="对象池（Object-Pool）"><a href="#对象池（Object-Pool）" class="headerlink" title="对象池（Object Pool）"></a>对象池（Object Pool）</h4><p>创建一个池子，把游戏可能会用到的资源提前创建，用到的时候将它 <strong>取出 SetActive(true)</strong> 并放到正确的位置，用完之后再 <strong>回收 SetActive(false)</strong> 而不是销毁，用空间换时间很好地解决了问题。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Pool-cs"><a href="#Pool-cs" class="headerlink" title="Pool.cs"></a>Pool.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]<span class="comment">// Serializable 特性可以在监视器窗口调整对象池内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject prefab;<span class="comment">// 存入的物体</span></span><br><span class="line">    Queue&lt;GameObject&gt; objectPool;<span class="comment">// 内存区（队列）池子本体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> defaultSize;<span class="comment">// 对象池初始容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxSize;<span class="comment">// 对象池最大容量，防止对象池无节制占用内存</span></span><br><span class="line">    Transform parent;<span class="comment">// 创建这个池子的物体时指定所属的父物体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对池子进行初始化，创建初始容量个数的物体，存入队列中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;parent&quot;&gt;</span>创建这个池子的物体时指定所属的父物体<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">Transform parent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        objectPool = <span class="keyword">new</span> Queue&lt;GameObject&gt;();<span class="comment">// 初始化队列</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; defaultSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Copy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 创建物体，并放入对象池中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">Copy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject copy = GameObject.Instantiate(prefab, parent);<span class="comment">// 实例化物体</span></span><br><span class="line">        objectPool.Enqueue(copy);<span class="comment">// 将实例化的物体入列</span></span><br><span class="line">        copy.SetActive(<span class="literal">false</span>);<span class="comment">// 隐藏该物体</span></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从对象池中拿出物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">GetObject</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject getObject;</span><br><span class="line">        <span class="keyword">if</span> (objectPool.Count &gt; <span class="number">0</span> &amp;&amp; !objectPool.Peek().activeSelf)<span class="comment">// 对象池中有物体，就拿出</span></span><br><span class="line">        &#123;</span><br><span class="line">            getObject = objectPool.Dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 对象池被拿空了还需要，就再创建一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            getObject = Copy();</span><br><span class="line">        &#125;</span><br><span class="line">        getObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> getObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 回收物体到池子中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;recycle&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecycleObject</span>(<span class="params">GameObject recycle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectPool.Count &lt;= maxSize)<span class="comment">// 池子中的物体不超过最大容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!objectPool.Contains(recycle))<span class="comment">// 该对象没有在队列中</span></span><br><span class="line">            &#123;</span><br><span class="line">                objectPool.Enqueue(recycle);</span><br><span class="line">                recycle.SetActive(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 超过最大容量就销毁</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameObject.Destroy(recycle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PoolManager-cs"><a href="#PoolManager-cs" class="headerlink" title="PoolManager.cs"></a>PoolManager.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处创建游戏中用到的池子</span></span><br><span class="line">    <span class="keyword">public</span> Pool[] bulletPools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;GameObject, Pool&gt; dic;<span class="comment">// 将游戏物体和所在的池子绑定到字典中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        dic = <span class="keyword">new</span> Dictionary&lt;GameObject, Pool&gt;();</span><br><span class="line">        Initialize(bulletPools);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化游戏对象，设置父物体</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;pools&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">Pool[] pools</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Pool pool <span class="keyword">in</span> pools)</span><br><span class="line">        &#123;</span><br><span class="line">            dic.Add(pool.prefab, pool);</span><br><span class="line">            Transform poolParent = <span class="keyword">new</span> GameObject(<span class="string">&quot;Pool: &quot;</span> + pool.prefab.name).transform;</span><br><span class="line">            poolParent.parent = transform;</span><br><span class="line">            pool.Initialize(poolParent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 根据传入的prefab，返回对象池中准备好的游戏对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;prefab&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">Release</span>(<span class="params">GameObject prefab</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dic[prefab].GetObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>增加一个 PoolManager 类的 Release 方法的重载，使物体创建时有一个初始位置：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">Release</span>(<span class="params">GameObject prefab, Vector3 position</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    prefab.transform.position = position;</span><br><span class="line">    <span class="keyword">return</span> dic[prefab].GetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个子弹类，包含子弹的移动与撞击物体时销毁（不是真的销毁，只是隐藏）</p>
<h6 id="Bullet-cs"><a href="#Bullet-cs" class="headerlink" title="Bullet.cs"></a>Bullet.cs</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> moveSpeed = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gameObject.activeSelf)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Translate(moveSpeed * <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gameObject.activeSelf &amp;&amp; collision.gameObject.name == <span class="string">&quot;Cube&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在游戏控制脚本中控制子弹射出</p>
<h6 id="GameController-cs"><a href="#GameController-cs" class="headerlink" title="GameController.cs"></a>GameController.cs</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;</span><br><span class="line">    <span class="keyword">public</span> Transform bulletPos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            PoolManager.Release(bullet, bulletPos.transform.position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行图片"><a href="#运行图片" class="headerlink" title="运行图片"></a>运行图片</h4><p><img src="/pool1.png"></p>
<p><img src="/pool2.png"></p>
<p><img src="/pool3.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%B3%BB%E7%BB%9F/" data-id="clmtdoooa001gegru2sew1tbg" data-title="设计模式：对象池系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/" rel="tag">对象池</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构与算法-排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2023-09-09T07:12:12.000Z" itemprop="datePublished">2023-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">数据结构与算法：排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><h4 id="排序方法："><a href="#排序方法：" class="headerlink" title="排序方法："></a>排序方法：</h4><p>（以下均为从小到大的正序排序）从数组的第一位向后，依次比较相邻的两个数据，如果前面的数据大于后面的数据，则两个元素交换位置。</p>
<p><img src="/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入需要排序的一组数字，以英文符号 &#x27;,&#x27; 分隔：&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> inputStr = Console.ReadLine();<span class="comment">// 获取用户输入字符串</span></span><br><span class="line"><span class="built_in">string</span>[] numsStr = inputStr.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">// 将用户输入存入String数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[numsStr.Length];<span class="comment">// 将String数组转为int数组（以后使用直接声明的数组）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numsStr.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    nums[i] = <span class="built_in">int</span>.Parse(numsStr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length - <span class="number">1</span>; i++)<span class="comment">// 外围循环每轮将一个最大数字送到最后</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; nums.Length - <span class="number">1</span> - i; j++)<span class="comment">// 内部循环每轮挑选较大数字并交换位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])<span class="comment">// 如果前面数大于后面数，两数交换位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[j + <span class="number">1</span>];</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;排序结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="选择排序（-Selection-Sort）"><a href="#选择排序（-Selection-Sort）" class="headerlink" title="选择排序（ Selection Sort）"></a>选择排序（ Selection Sort）</h3><h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><p>将数组分为排序区和未排序区，遍历未排序区的元素找到最小值，将它放在未排序区的第一位。</p>
<p><img src="/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i  = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; nums.Length - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minIndex = i;<span class="comment">// 记录最小数字的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j= i + <span class="number">1</span>; j&lt; nums.Length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[minIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            minIndex = j;<span class="comment">// 更新最小数字的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小数字之后与未排序区的第一个数交换位置</span></span><br><span class="line">    <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[minIndex];</span><br><span class="line">    nums[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><h4 id="排序方法：-1"><a href="#排序方法：-1" class="headerlink" title="排序方法："></a>排序方法：</h4><p>将数组分为已排序区域和未排序区域，将未排序区域的数依次与已排序区域的数比较并插入到正确位置，如果比它大则交换位置，如果比它小则位置不变并插入。</p>
<p><img src="/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i  = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.Length; i++)<span class="comment">// 默认第一个数已排序，遍历未排序区的每一个数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sortNum = nums[i];<span class="comment">// 当前正在插入的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)<span class="comment">// 从后往前遍历已排序区的数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; sortNum)<span class="comment">// 选择正确的位置并插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = sortNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="希尔排序（Shell’s-Sort）"><a href="#希尔排序（Shell’s-Sort）" class="headerlink" title="希尔排序（Shell’s Sort）"></a>希尔排序（Shell’s Sort）</h3><h4 id="排序方法-1"><a href="#排序方法-1" class="headerlink" title="排序方法"></a>排序方法</h4><p>是插入排序的升级版，加入了分组的规则，将数组分成多个子数组分别进行插入排序。</p>
<p><img src="/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>在插入排序的代码外围套一层for循环，加入了步长的概念，相当于普通插入排序的步长一直为1，希尔排序将1替换为步长。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> step = nums.Length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>)<span class="comment">// 步长step初始为数组长度的1/2，每次循环变为原步长的1/2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = step; i &lt; nums.Length; i += step)<span class="comment">// 每次指针的加减不为1，改为步长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sortNum = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = i - step; j &gt;= <span class="number">0</span>; j -= step)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; sortNum)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j + step] = nums[j];</span><br><span class="line">                nums[j] = sortNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><h4 id="排序方法：-2"><a href="#排序方法：-2" class="headerlink" title="排序方法："></a>排序方法：</h4><p>是对冒泡排序的改进，通过一趟排序将要排序的数据分割成两部分，其中一部分的所有数据都比另一部分的所有数据小，然后对两部分再次进行快速排序，递归直到排序完成。</p>
<p>快速排序首先会在序列中随机选择一个基准值，然后将除了基准值以外的数分<br>为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。<br><strong>[ 比基准值小的数] 基准值 [ 比基准值大的数]</strong><br>接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。<br>对“[ ]”里面的数据 进行排序时同样也会使用快速排序。</p>
<p><img src="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)<span class="comment">// 若数组的左端下标大于或等于右端下标，则表明数组为一或空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 结束递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> i = left;</span><br><span class="line">    <span class="built_in">int</span> j = right;</span><br><span class="line">    <span class="built_in">int</span> pivot = nums[left];<span class="comment">// 取当前数组第一个数为基准数，并记录</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)<span class="comment">// 当i = j时退出，表示pivot左边的数都比pivot小，右边的数都比pivot大</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; pivot &lt;= nums[j])<span class="comment">// 从后往前找比pivot小的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)<span class="comment">// 从前往后找比pivot大的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)<span class="comment">// 交换数组中大于基准值的数和小于基准值的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准值放到大数组和小数组中键</span></span><br><span class="line">    nums[left] = nums[i];</span><br><span class="line">    nums[i] = pivot;</span><br><span class="line">    QuickSort(nums, left, i - <span class="number">1</span>);<span class="comment">// 对比新的轴小的部分递归排序</span></span><br><span class="line">    QuickSort(nums,i + <span class="number">1</span>, right);<span class="comment">// 对比新的轴大的部分递归排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuickSort(nums, <span class="number">0</span>, nums.Length - <span class="number">1</span>);<span class="comment">// 调用测试</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果：-2"><a href="#运行结果：-2" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><h4 id="排序方法：-3"><a href="#排序方法：-3" class="headerlink" title="排序方法："></a>排序方法：</h4><p><img src="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums = Merge(nums);<span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 负责排序</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>传入的左数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>传入的右数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] left, <span class="built_in">int</span>[] right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[left.Length + right.Length];<span class="comment">// 先准备一个新数组</span></span><br><span class="line">    <span class="built_in">int</span> leftIndex = <span class="number">0</span>;<span class="comment">// 左数组索引</span></span><br><span class="line">    <span class="built_in">int</span> rightIndex = <span class="number">0</span>;<span class="comment">// 右数组索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)<span class="comment">// for循环目的是填满这个新数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.如果一边的数组放完了，则直接放另一边的数</span></span><br><span class="line">        <span class="keyword">if</span> (leftIndex &gt;= left.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = right[rightIndex];</span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rightIndex &gt;= right.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = left[leftIndex];</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.将左右两数组的数从小到大放入新数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = left[leftIndex];</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left[leftIndex] &gt; right[rightIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = right[rightIndex];</span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;<span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 负责分组，调用排序</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>每次排好序的新数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">Merge</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 递归的结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (array.Length &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组分两段</span></span><br><span class="line">    <span class="built_in">int</span> mid = array.Length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化左右数组</span></span><br><span class="line">    <span class="built_in">int</span>[] left = <span class="keyword">new</span> <span class="built_in">int</span>[mid];</span><br><span class="line">    <span class="built_in">int</span>[] right = <span class="keyword">new</span> <span class="built_in">int</span>[array.Length - mid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            right[i - mid] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不断调用Merge直到数组长度为1不能再分，然后进行排序，一层一层向上返回直到返回完整数组</span></span><br><span class="line">    <span class="keyword">return</span> Sort(Merge(left), Merge(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行结果：-3"><a href="#运行结果：-3" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>
<hr>
<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><h4 id="排序方法：-4"><a href="#排序方法：-4" class="headerlink" title="排序方法："></a>排序方法：</h4><p>堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的，每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最小（大）堆，依次类推，最终得到排序的序列。</p>
<p><img src="/%E5%A0%86%E6%8E%92%E5%BA%8F.gif"></p>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123; <span class="number">44</span>, <span class="number">67</span>, <span class="number">5</span>, <span class="number">53</span>, <span class="number">86</span>, <span class="number">93</span>, <span class="number">24</span>, <span class="number">9</span>, <span class="number">80</span>, <span class="number">17</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;原数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeapSort(nums, nums.Length);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n排序结果为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(nums[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 堆排序</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最小堆，依次类推，最终得到排序的序列。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;arr&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;length&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreateHeap(arr, length);</span><br><span class="line">        <span class="comment">//从最后的节点进行调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换堆顶和最后一个节点的元素</span></span><br><span class="line">            <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            <span class="comment">//每次交换进行调整</span></span><br><span class="line">            AdjustHeap(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 1）n 个结点的完全二叉树，则最后一个结点是第n/2个结点的子树。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 2）筛选从第n/2个结点为根的子树开始，该子树成为堆。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateHeap</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            AdjustHeap(arr, i, length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AdjustHeap</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> start, <span class="built_in">int</span> length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> root = start;</span><br><span class="line">        <span class="built_in">int</span> child = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt;= length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= length &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父节点大於子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[root] &gt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">                <span class="built_in">int</span> temp = arr[root];</span><br><span class="line">                arr[root] = arr[child];</span><br><span class="line">                arr[child] = temp;</span><br><span class="line"></span><br><span class="line">                root = child;</span><br><span class="line">                child = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果：-4"><a href="#运行结果：-4" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" data-id="clmtdooo4000gegruays7e8vh" data-title="数据结构与算法：排序" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E5%9F%BA%E7%A1%80/" rel="tag">C#基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-初学有限状态机" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/03/%E5%88%9D%E5%AD%A6%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" class="article-date">
  <time class="dt-published" datetime="2023-09-03T01:30:32.000Z" itemprop="datePublished">2023-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/03/%E5%88%9D%E5%AD%A6%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/">初学有限状态机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="想象一下"><a href="#想象一下" class="headerlink" title="想象一下"></a>想象一下</h3><p>想象一个场景，你有一个ARPG游戏里的角色，你的角色有很多骚气的动作：蹬墙跳、滑铲、二段跳、滑翔、过肩摔、格挡反击、咸鱼冲刺、吹口哨……</p>
<p>但是，你的角色并不能在滑铲的时候使出咸鱼冲刺，在滑翔的时候对着敌人使出过肩摔，在挨打的时候对着怪吹口哨，否则其他看到的玩家就会直呼：卧槽，有挂</p>
<p>如果你是Unity菜鸟，你会怎样设计角色控制代码呢，正好我就是菜鸟，我会告诉你应该这样做：声明一溜布尔值来判断角色所处的状态</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isGround;<span class="comment">// 在地面上</span></span><br><span class="line"><span class="built_in">bool</span> isHuaXiang;<span class="comment">// 正在滑翔</span></span><br><span class="line"><span class="built_in">bool</span> isHurt;<span class="comment">// 正在挨打</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>当按下动作按键时用if来判断</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!isHurt)</span><br><span class="line">	ChuiKouShao();<span class="comment">// 如果角色没有在挨打，就对着怪吹口哨嘲讽</span></span><br></pre></td></tr></table></figure>

<p>当然，学过有限状态机的你对着我的嘴就是一巴掌：如果角色的状态和行为不断变得复杂，慢慢的，你会创建114514个条件变量，慢慢的，if层级会越来越多。。然后你交给了我一个新的方法——有限状态机：</p>
<hr>
<h3 id="一个有限状态机"><a href="#一个有限状态机" class="headerlink" title="一个有限状态机"></a>一个有限状态机</h3><p>FSM，有限状态机，可以枚举出有限多个状态，当满足特定的条件时可以在这些条件中来回切换</p>
<p>比如游戏中的敌人AI，正常情况下敌人会在特定的路线上来回走动进行巡逻，当玩家发出动静或者首次进入视野时会警觉，这时候玩家再次发出动静或者暴露在视野中敌人就会追击玩家，直到玩家消失在视野中</p>
<p>Unity当中的Animator就是一个FSM：</p>
<p><img src="/1.png" alt="Animator"></p>
<p>只不过每个状态里存放的是动画，我们的FSM也会沿用这个思想，只不过状态里存放的是逻辑代码</p>
<p>FSM可以说是一个强化版的 switch case ，判断处于哪个状态，执行对应的逻辑，FSM可以很方便地进行扩展，加入新状态只需继承基类，不用修改原来的代码</p>
<h3 id="构建有限状态机"><a href="#构建有限状态机" class="headerlink" title="构建有限状态机"></a>构建有限状态机</h3><h4 id="状态机管理器类"><a href="#状态机管理器类" class="headerlink" title="状态机管理器类"></a>状态机管理器类</h4><p>用来记录与统一所有状态</p>
<h4 id="状态的基类"><a href="#状态的基类" class="headerlink" title="状态的基类"></a>状态的基类</h4><p>抽象类，只能被继承。所有状态都具有的共同行为</p>
<p>OnEnter、OnUpdate、OnExit</p>
<h4 id="单个状态类"><a href="#单个状态类" class="headerlink" title="单个状态类"></a>单个状态类</h4><p>每个状态单独一个类，存放这个状态拥有的逻辑代码，继承于状态基类</p>
<h4 id="角色对象类"><a href="#角色对象类" class="headerlink" title="角色对象类"></a>角色对象类</h4><p>创建StateMachineManager类的实例，每个角色都有自己专属的状态机，因此StateMachineManager类不能是抽象类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/03/%E5%88%9D%E5%AD%A6%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" data-id="clmtdooo1000begru79lxdm12" data-title="初学有限状态机" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learn/" rel="tag">learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" rel="tag">有限状态机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Lua学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T15:09:09.000Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Lua学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="第一个Lua程序"><a href="#第一个Lua程序" class="headerlink" title="第一个Lua程序"></a>第一个Lua程序</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Lua 语句不用写分号</p>
<hr>
<h3 id="Lua-注释："><a href="#Lua-注释：" class="headerlink" title="Lua 注释："></a>Lua 注释：</h3><p>单行注释</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--单行注释</span></span><br></pre></td></tr></table></figure>

<p>多行注释</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Lua-标示符"><a href="#Lua-标示符" class="headerlink" title="Lua 标示符"></a>Lua 标示符</h3><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 <strong>_</strong> 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。</p>
<p>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>Lua 不允许使用特殊字符如 <strong>@</strong>, <strong>$</strong>, 和 <strong>%</strong> 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Runoob 与 runoob 是两个不同的标示符。以下列出了一些正确的标示符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd         zara      abc     move_name    a_123</span><br><span class="line">myname50     _temp     j       a23b9        retVal</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Lua-关键词"><a href="#Lua-关键词" class="headerlink" title="Lua 关键词"></a>Lua 关键词</h3><p>以下列出了 Lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">break</td>
<td align="left">do</td>
<td align="left">else</td>
</tr>
<tr>
<td align="left">elseif</td>
<td align="left">end</td>
<td align="left">false</td>
<td align="left">for</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">if</td>
<td align="left">in</td>
<td align="left">local</td>
</tr>
<tr>
<td align="left">nil</td>
<td align="left">not</td>
<td align="left">or</td>
<td align="left">repeat</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">then</td>
<td align="left">true</td>
<td align="left">until</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">goto</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<hr>
<h3 id="Lua-全局变量"><a href="#Lua-全局变量" class="headerlink" title="Lua 全局变量"></a>Lua 全局变量</h3><p>一般来说，所有变量都是全局的，一个变量没有进行初始化时，他的值默认是 nil</p>
<hr>
<h3 id="Lua-数据类型"><a href="#Lua-数据类型" class="headerlink" title="Lua 数据类型"></a>Lua 数据类型</h3><p>和 Python 一样，Lua 是动态类型语言，不需要定义变量的类型，尽管赋值</p>
<p>Lua 中有8个基本类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>表示一个无效值或者空值，在条件表达式中相当于false</td>
</tr>
<tr>
<td>boolean</td>
<td>表示条件：true 和 false</td>
</tr>
<tr>
<td>number</td>
<td>表示双精度类型的实浮点数，所有数字</td>
</tr>
<tr>
<td>string</td>
<td>字符串，用 “” 或 ‘’ 表示</td>
</tr>
<tr>
<td>function</td>
<td>函数方法</td>
</tr>
<tr>
<td>userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td>thread</td>
<td>表示执行的独立线路，用于执行协同程序，多线程</td>
</tr>
<tr>
<td>table</td>
<td>其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。用 {} 来创建</td>
</tr>
</tbody></table>
<p>用 type 函数测试变量或者值的类型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello Caromeow&quot;</span>))    <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">114514</span>))              <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))                <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))                <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                 <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))             <span class="comment">--&gt; string</span></span><br></pre></td></tr></table></figure>

<h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p>
<p>nil 作比较时应该加上双引号</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">type</span>(x) == <span class="literal">nil</span>        <span class="comment">--&gt; false</span></span><br><span class="line"><span class="built_in">type</span>(x) == <span class="string">&quot;nil&quot;</span>      <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure>

<h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>Lua 把 false 和 nil 看作是 false，其他都为 true，数字 0 也是 true</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 是 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 是 false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>    <span class="comment">--&gt; 数字 0 是 true</span></span><br></pre></td></tr></table></figure>

<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>Lua 只有一种数字类型 number – doube（双精度）类型</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>用 2 个方括号 “[[]]” 表示多行字符串</p>
<p>字符串连接使用的是两个点 ..</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">985</span> .. <span class="number">996</span>)    <span class="comment">--&gt; 985996</span></span><br></pre></td></tr></table></figure>

<p>用 # 表示字符串的长度，字母和符号占1个长度，汉字占3个长度</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#<span class="string">&quot;Q弹好味&quot;</span>)    <span class="comment">--&gt; 10</span></span><br></pre></td></tr></table></figure>

<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>使用 {} 创建</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空表</span></span><br><span class="line">table1 = &#123;&#125;</span><br><span class="line"><span class="comment">-- 直接初始化表</span></span><br><span class="line">table2 = &#123;<span class="string">&quot;牛&quot;</span>, <span class="string">&quot;马&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--&gt; key : value</span></span><br><span class="line"><span class="comment">--&gt; 10 : 33</span></span><br></pre></td></tr></table></figure>

<p><strong>Lua 表的索引从 1 开始</strong></p>
<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br><span class="line"><span class="comment">--&gt; 120</span></span><br><span class="line"><span class="comment">--&gt; 120</span></span><br></pre></td></tr></table></figure>

<h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p>
<p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p>
<h4 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h4><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>
<h3 id="Lua-变量"><a href="#Lua-变量" class="headerlink" title="Lua 变量"></a>Lua 变量</h3><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p>Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p>
<p>变量的默认值均为 nil</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure>

<p>应该尽可能的使用局部变量，有两个好处：</p>
<ol>
<li><p>避免命名冲突。</p>
</li>
<li><p>访问局部变量的速度比全局变量更快。</p>
</li>
</ol>
<h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>给多个变量同时赋值</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="string">&quot;西&quot;</span></span><br></pre></td></tr></table></figure>

<p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="string">&quot;左&quot;</span>, <span class="string">&quot;右&quot;</span></span><br><span class="line">x, y = y, x</span><br><span class="line"><span class="built_in">print</span>(x .. y)    <span class="comment">--&gt; &quot;右&quot;&quot;左&quot;</span></span><br></pre></td></tr></table></figure>

<p>当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 变量个数 &gt; 值的个数             按变量个数补足nil</span><br><span class="line">b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br></pre></td></tr></table></figure>

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t.i                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line">gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure>

<h3 id="Lua-循环"><a href="#Lua-循环" class="headerlink" title="Lua 循环"></a>Lua 循环</h3><p>Lua 语言提供了以下几种循环处理方式：</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">while 循环</td>
<td align="left">在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。</td>
</tr>
<tr>
<td align="left">for 循环</td>
<td align="left">重复执行指定语句，重复次数可在 for 语句中控制。</td>
</tr>
<tr>
<td align="left">repeat…until</td>
<td align="left">重复执行循环，直到 指定的条件为真时为止</td>
</tr>
<tr>
<td align="left">循环嵌套</td>
<td align="left">可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;）</td>
</tr>
</tbody></table>
<h4 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h4><table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break 语句</td>
<td align="left">退出当前循环或语句，并开始脚本执行紧接着的语句。</td>
</tr>
<tr>
<td align="left">goto 语句</td>
<td align="left">将程序的控制点转移到一个标签处。</td>
</tr>
</tbody></table>
<p><strong>goto</strong></p>
<p>Lua 语言中的 goto 语句允许将控制流程无条件地转到被标记的语句处。</p>
<p>语法格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goto Label</span><br></pre></td></tr></table></figure>

<p>Label 的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:: Label ::</span><br></pre></td></tr></table></figure>

<p>以下实例在判断语句中使用 goto：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">::label:: <span class="built_in">print</span>(<span class="string">&quot;--- goto label ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = a+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">goto</span> label  <span class="comment">-- a 小于 3 的时候跳转到标签 label</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- goto label ---</span><br><span class="line">--- goto label ---</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，多输出了一次 **— goto label —**。</p>
<p>以下实例演示了可以在 lable 中设置多个语句：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">::s1:: <span class="keyword">do</span></span><br><span class="line"> <span class="built_in">print</span>(i)</span><br><span class="line"> i = i+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> i&gt;<span class="number">3</span> <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">os</span>.<span class="built_in">exit</span>()  <span class="comment">-- i 大于 3 时退出</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">goto</span> s1</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>有了 goto，我们可以实现 continue 的功能：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> i &lt;= <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(i, <span class="string">&quot;yes continue&quot;</span>)</span><br><span class="line">    <span class="keyword">goto</span> continue</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">print</span>(i, <span class="string">&quot;no continue&quot;</span>)</span><br><span class="line">  ::continue::</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">[[i&#x27;m end]]</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   yes continue</span><br><span class="line">i&#x27;m end</span><br><span class="line">2   yes continue</span><br><span class="line">i&#x27;m end</span><br><span class="line">3    no continue</span><br><span class="line">i&#x27;m end</span><br></pre></td></tr></table></figure>

<h3 id="Lua-函数"><a href="#Lua-函数" class="headerlink" title="Lua 函数"></a>Lua 函数</h3><p>Lua 编程语言函数定义格式如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>optional_function_scope:</strong> 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</li>
<li><strong>function_name:</strong> 指定函数名称。</li>
<li><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</li>
<li><strong>result_params_comma_separated:</strong> 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 函数返回两个值的最大值 --]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span><span class="params">(num1, num2)</span></span></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) <span class="keyword">then</span></span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两值比较最大值为 &quot;</span>,<span class="built_in">max</span>(<span class="number">10</span>,<span class="number">4</span>))     <span class="comment">----&gt; 两值比较最大值为 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;两值比较最大值为 &quot;</span>,<span class="built_in">max</span>(<span class="number">5</span>,<span class="number">6</span>))      <span class="comment">----&gt; 两值比较最大值为 6</span></span><br></pre></td></tr></table></figure>

<p><strong>多返回值</strong></p>
<p>Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;www.runoob.com&quot;</span>, <span class="string">&quot;runoob&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(s, e)    <span class="comment">--&gt; 5 10</span></span><br></pre></td></tr></table></figure>

<p>Lua函数中，在return后列出要返回的值的列表即可返回多值，如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))    <span class="comment">--&gt; 23 3</span></span><br></pre></td></tr></table></figure>

<p><strong>可变参数</strong></p>
<p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 <strong>…</strong> 表示函数有可变的参数。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;    <span class="comment">--&gt; arg 为一个表，局部变量</span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. #<span class="built_in">arg</span> .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值为&quot;</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment">--&gt; 总共传入 6 个数</span></span><br><span class="line"><span class="comment">--&gt; 平均值为 5.5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))     </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">&quot;runoob\n&quot;</span>)       <span class="comment">---&gt;fmt = &quot;runoob&quot;, 没有变长参数。  </span></span><br><span class="line">fwrite(<span class="string">&quot;%d%d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2</span></span><br><span class="line"><span class="comment">--&gt; runoob</span></span><br><span class="line"><span class="comment">--&gt; 12</span></span><br></pre></td></tr></table></figure>

<p>通常在遍历变长参数的时候只需要使用 <strong>{…}<strong>，然而变长参数可能会包含一些 <strong>nil</strong>，那么就可以用 <strong>select</strong> 函数来访问变长参数了：</strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p>
<ul>
<li><strong>select(‘#’, …)</strong> 返回可变参数的长度。</li>
<li><strong>select(n, …)</strong> 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li>
</ul>
<p>调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 <strong>n</strong> 开始到结束位置的所有参数列表，否则只能为字符串 **#**，这样 select 返回变长参数的总数。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">    a = <span class="built_in">select</span>(<span class="number">3</span>,...)  <span class="comment">--&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span></span><br><span class="line">    <span class="built_in">print</span> (a)</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">select</span>(<span class="number">3</span>,...)) <span class="comment">--&gt;打印所有列表参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">--&gt; 2</span></span><br><span class="line"><span class="comment">--&gt; 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<h3 id="Lua-运算符"><a href="#Lua-运算符" class="headerlink" title="Lua 运算符"></a>Lua 运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left">A + B 输出结果 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left">A - B 输出结果 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left">A * B 输出结果 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除法</td>
<td align="left">B &#x2F; A 输出结果 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left">B % A 输出结果 0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">乘幂</td>
<td align="left">A^2 输出结果 100</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">负号</td>
<td align="left">-A 输出结果 -10</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;</td>
<td align="left">整除运算符(&gt;&#x3D;lua5.3)</td>
<td align="left"><strong>5&#x2F;&#x2F;2</strong> 输出结果 2</td>
</tr>
</tbody></table>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">等于，检测两个值是否相等，相等返回 true，否则返回 false</td>
<td align="left">(A &#x3D;&#x3D; B) 为 false。</td>
</tr>
<tr>
<td align="left">~&#x3D;</td>
<td align="left">不等于，检测两个值是否相等，不相等返回 true，否则返回 false</td>
<td align="left">(A ~&#x3D; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于，如果左边的值大于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt; B) 为 false。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于，如果左边的值大于右边的值，返回 false，否则返回 true</td>
<td align="left">(A &lt; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt;&#x3D; B) 返回 false。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &lt;&#x3D; B) 返回 true。</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td>
<td align="left">(A and B) 为 false。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。</td>
<td align="left">(A or B) 为 true。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td>
<td align="left">not(A and B) 为 true。</td>
</tr>
</tbody></table>
<h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">..</td>
<td align="left">连接两个字符串</td>
<td align="left">a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">一元运算符，返回字符串或表的长度。</td>
<td align="left">#”Hello” 返回 5</td>
</tr>
</tbody></table>
<h3 id="Lua-字符串"><a href="#Lua-字符串" class="headerlink" title="Lua 字符串"></a>Lua 字符串</h3><ul>
<li><p>单引号间的一串字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> str1 = <span class="string">&#x27;This is a string.&#x27;</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&quot;This is also a string.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双引号间的一串字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> str = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str = str .. <span class="string">&quot;World!&quot;</span>  <span class="comment">-- 创建一个新的字符串并将其赋值给str</span></span><br><span class="line"><span class="built_in">print</span>(str)  <span class="comment">-- 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> multilineString = <span class="string">[[</span></span><br><span class="line"><span class="string">This is a multiline string.</span></span><br><span class="line"><span class="string">It can contain multiple lines of text.</span></span><br><span class="line"><span class="string">No need for escape characters.</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(multilineString)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串长度计算"><a href="#字符串长度计算" class="headerlink" title="字符串长度计算"></a>字符串长度计算</h4><p>在 Lua 中，要计算字符串的长度（即字符串中字符的个数），你可以使用 <strong>string.len</strong>函数或 <strong>utf8.len</strong> 函数，包含中文的一般用 <strong>utf8.len</strong>，<strong>string.len</strong> 函数用于计算只包含 ASCII 字符串的长度。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> myString = <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算字符串的长度（字符个数）</span></span><br><span class="line"><span class="keyword">local</span> length1 = utf8.<span class="built_in">len</span>(myString)</span><br><span class="line"><span class="built_in">print</span>(length1) <span class="comment">--&gt; 输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- string.len 函数会导致结果不准确（中文算3个字符）</span></span><br><span class="line"><span class="keyword">local</span> length2 = <span class="built_in">string</span>.<span class="built_in">len</span>(myString)</span><br><span class="line"><span class="built_in">print</span>(length2) <span class="comment">--&gt; 输出 14</span></span><br></pre></td></tr></table></figure>

<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>转义字符用于表示不能直接显示的字符，比如后退键，回车键等，如在字符串转换双引号可以使用 ****。</p>
<p>所有的转义字符和所对应的意义：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\\</td>
<td>代表一个反斜线字符”\“</td>
<td>092</td>
</tr>
<tr>
<td>\‘</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\“</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>Lua 提供了很多的方法来支持字符串的操作：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>string.upper(argument):</strong> 字符串全部转为大写字母。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>string.lower(argument):</strong> 字符串全部转为小写字母。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>string.gsub(mainString,findString,replaceString,num)</strong>: 在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：<code>&gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3); zzza  3</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>string.find (str, substr, [init, [plain]])</strong>: 在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。<strong>init</strong> 指定了搜索的起始位置，默认为 1，可以一个负数，表示从后往前数的字符个数。<strong>plain</strong> 表示是否使用简单模式，默认为 false，true 只做简单的查找子串的操作，false 表示使用使用正则模式匹配。以下实例查找字符串 “Lua” 的起始索引和结束索引位置：<code>&gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)  7  9</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>string.reverse(arg)</strong>: 字符串反转<code>&gt; string.reverse(&quot;Lua&quot;) auL</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>string.format(…)</strong>: 返回一个类似printf的格式化字符串<code>&gt; string.format(&quot;the value is:%d&quot;,4) the value is:4</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>string.char(arg) 和 string.byte(arg[,int])</strong>: char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。<code>&gt; string.char(97,98,99,100) abcd &gt; string.byte(&quot;ABCD&quot;,4) 68 &gt; string.byte(&quot;ABCD&quot;) 65 &gt;</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>string.len(arg)</strong>: 计算字符串长度。<code>string.len(&quot;abc&quot;) 3</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>string.rep(string, n)</strong>: 返回字符串string的n个拷贝<code>&gt; string.rep(&quot;abcd&quot;,2) abcdabcd</code></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>..</strong> 链接两个字符串<code>&gt; print(&quot;www.runoob.&quot;..&quot;com&quot;) www.runoob.com</code></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>string.gmatch(str, pattern)</strong>: 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。<code>&gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end Hello Lua user</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>string.match(str, pattern, init)</strong>: string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。<code>&gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;) 2 questions &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;)) 2, &quot;questions&quot;</code></td>
</tr>
</tbody></table>
<p><strong>字符串截取</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(s, i [, j])</span><br></pre></td></tr></table></figure>

<p>s: 要截取的字符串</p>
<p>i: 截取开始位置</p>
<p>j: 结束位置，默认为 -1，最后一个字符</p>
<p><strong>字符串格式化</strong></p>
<p>Lua 提供了 <strong>string.format()</strong> 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p>
<p>由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p>
<p>以下实例演示了如何对字符串进行格式化操作：</p>
<p>格式字符串可能包含以下的转义码:</p>
<ul>
<li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li>
<li>%o - 接受一个数字并将其转化为八进制数格式</li>
<li>%u - 接受一个数字并将其转化为无符号整数格式</li>
<li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li>%f - 接受一个数字并将其转化为浮点数格式</li>
<li>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li>
<li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<p>为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p>
<ul>
<li>(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li>
<li>(2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li>
<li>(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li>
<li>(4) 宽度数值</li>
<li>(5) 小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;Tutorial&quot;</span></span><br><span class="line">number1 = <span class="number">10</span></span><br><span class="line">number2 = <span class="number">20</span></span><br><span class="line"><span class="comment">-- 基本字符串格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;基本格式化 %s %s&quot;</span>,string1,string2))</span><br><span class="line"><span class="comment">--&gt; Lua Tutorial</span></span><br><span class="line"><span class="comment">-- 日期格式化</span></span><br><span class="line"><span class="built_in">date</span> = <span class="number">30</span>; month = <span class="number">8</span>; year = <span class="number">2023</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;日期格式化 %02d/%02d/%03d&quot;</span>, <span class="built_in">date</span>, month, year))</span><br><span class="line"><span class="comment">--&gt; 02/01/2023</span></span><br><span class="line"><span class="comment">-- 十进制格式化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%.4f&quot;</span>,<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line"><span class="comment">--&gt; 0.3333</span></span><br></pre></td></tr></table></figure>

<p><strong>字符与整数相互转换</strong></p>
<p>以下实例演示了字符与整数相互转换：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符转换</span></span><br><span class="line"><span class="comment">-- 转换第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>))    <span class="comment">--&gt; 76</span></span><br><span class="line"><span class="comment">-- 转换第三个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">3</span>))  <span class="comment">--&gt; 97</span></span><br><span class="line"><span class="comment">-- 转换末尾第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">-1</span>)) <span class="comment">--&gt; 97</span></span><br><span class="line"><span class="comment">-- 第二个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">2</span>))  <span class="comment">--&gt; 117</span></span><br><span class="line"><span class="comment">-- 转换末尾第二个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">-2</span>)) <span class="comment">--&gt; 117</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 整数 ASCII 码转换为字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">97</span>))       <span class="comment">--&gt; a</span></span><br></pre></td></tr></table></figure>

<p><strong>匹配模式</strong></p>
<p>Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 <strong>string.find, string.gmatch, string.gsub, string.match</strong>。</p>
<p>你还可以在模式串中使用字符类。</p>
<p>字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 <strong>%d</strong> 匹配任意数字。所以你可以使用模式串 <strong>%d%d&#x2F;%d%d&#x2F;%d%d%d%d</strong> 搜索 <strong>dd&#x2F;mm&#x2F;yyyy</strong> 格式的日期：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Deadline is 30/05/1999, firm&quot;</span></span><br><span class="line"><span class="built_in">date</span> = <span class="string">&quot;%d%d/%d%d/%d%d%d%d&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(s, <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="built_in">date</span>)))   *<span class="comment">--&gt; 30/05/1999*</span></span><br></pre></td></tr></table></figure>

<p>下面的表列出了Lua支持的所有字符类：</p>
<p>单个字符(除 <strong>^$()%.[]*+-?</strong> 外): 与该字符自身配对</p>
<ul>
<li><p>.(点): 与任何字符配对</p>
</li>
<li><p>%a: 与任何字母配对</p>
</li>
<li><p>%c: 与任何控制符配对(例如\n)</p>
</li>
<li><p>%d: 与任何数字配对</p>
</li>
<li><p>%l: 与任何小写字母配对</p>
</li>
<li><p>%p: 与任何标点(punctuation)配对</p>
</li>
<li><p>%s: 与空白字符配对</p>
</li>
<li><p>%u: 与任何大写字母配对</p>
</li>
<li><p>%w: 与任何字母&#x2F;数字配对</p>
</li>
<li><p>%x: 与任何十六进制数配对</p>
</li>
<li><p>%z: 与任何代表0的字符配对</p>
</li>
<li><p>%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对</p>
</li>
<li><p>[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母&#x2F;数字, 或下划线符号(_)配对</p>
</li>
<li><p>[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对</p>
</li>
</ul>
<p>当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))</span><br><span class="line">hello..up.down.    4</span><br></pre></td></tr></table></figure>

<p>数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。</p>
<p>在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) . % + - * ? [ ^ $</span><br></pre></td></tr></table></figure>

<p>‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%’不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。</p>
<p><strong>模式条目可以是：</strong></p>
<ul>
<li>单个字符类匹配该类别中任意单个字符；</li>
<li>单个字符类跟一个 ‘<code>*</code>‘， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>+</code>‘， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>-</code>‘， 将匹配零或更多个该类的字符。 和 ‘<code>*</code>‘ 不同， 这个条目总是匹配尽可能短的串；</li>
<li>单个字符类跟一个 ‘<code>?</code>‘， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；</li>
<li><code>%*n*</code>， 这里的 <em>n</em> 可以从 1 到 9； 这个条目匹配一个等于 <em>n</em> 号捕获物（后面有描述）的子串。</li>
<li><code>%b*xy*</code>， 这里的 <em>x</em> 和 <em>y</em> 是两个明确的字符； 这个条目匹配以 <em>x</em> 开始 <em>y</em> 结束， 且其中 <em>x</em> 和 <em>y</em> 保持 <em>平衡</em> 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 <em>x</em> 就 <em>+1</em> ，读到一个 <em>y</em> 就 <em>-1</em>， 最终结束处的那个 <em>y</em> 是第一个记数到 0 的 <em>y</em>。 举个例子，条目 <code>%b()</code> 可以匹配到括号平衡的表达式。</li>
<li><code>%f[*set*]</code>， 指 <em>边境模式</em>； 这个条目会匹配到一个位于 <em>set</em> 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 <em>set</em> 。 集合 <em>set</em> 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘<code>\0</code>‘ 一样。</li>
</ul>
<p><strong>模式：</strong></p>
<p><em>模式</em> 指一个模式条目的序列。 在模式最前面加上符号 ‘<code>^</code>‘ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘<code>$</code>‘ 将使匹配过程锚定到字符串的结尾。 如果 ‘<code>^</code>‘ 和 ‘<code>$</code>‘ 出现在其它位置，它们均没有特殊含义，只表示自身。</p>
<p><strong>捕获：</strong></p>
<p>模式可以在内部用小括号括起一个子模式； 这些子模式被称为 <em>捕获物</em>。 当匹配成功时，由 <em>捕获物</em> 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 <code>&quot;(a*(.)%w(%s*))&quot;</code> ， 字符串中匹配到 <code>&quot;a*(.)%w(%s*)&quot;</code> 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “<code>.</code>“ 匹配到的字符是 2 号捕获物， 匹配到 “<code>%s*</code>“ 的那部分是 3 号。</p>
<p>作为一个特例，空的捕获 <code>()</code> 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 <code>&quot;()aa()&quot;</code> 作用到字符串 <code>&quot;flaaap&quot;</code> 上，将产生两个捕获物： 3 和 5 。</p>
<h3 id="Lua-数组"><a href="#Lua-数组" class="headerlink" title="Lua 数组"></a>Lua 数组</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="clmtdoonr0000egru31sv9vhw" data-title="Lua学习笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity3D手游开发中的特殊文件夹" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/29/Unity3D%E6%89%8B%E6%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/" class="article-date">
  <time class="dt-published" datetime="2023-08-29T05:46:17.000Z" itemprop="datePublished">2023-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/29/Unity3D%E6%89%8B%E6%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/">Unity3D手游开发中的特殊文件夹</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>z</p>
<p>这里列举出手游开发中用到的所有特殊文件夹</p>
<p><img src="/1.png"></p>
<h4 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h4><p>Editor文件夹可以在根目录下，也可以在子目录里，只要名子叫Editor就可以。比如目录：&#x2F;xxx&#x2F;xxx&#x2F;Editor  和 &#x2F;Editor 是一样的，无论多少个叫Editor的文件夹都可以。Editor下面放的所有资源文件或者脚本文件都不会被打进发布包中，并且脚本也只能在编辑时使用。一般呢会把一些工具类的脚本放在这里，或者是一些编辑时用的DLL。 比如我们现在要做类似技能编辑器，那么编辑器的代码放在这里是再好不过了，因为实际运行时我们只需要编辑器生成的文件，而不需要编辑器的核心代码。</p>
<h4 id="Editor-Default-Resources"><a href="#Editor-Default-Resources" class="headerlink" title="Editor Default Resources"></a>Editor Default Resources</h4><p>Editor Default Resources注意中间是有空格的，它必须放在Project视图的根目录下，如果你想放在&#x2F;xxx&#x2F;xxx&#x2F;Editor Default Resources 这样是不行的。你可以把编辑器用到的一些资源放在这里，比如图片、文本文件、等等。它和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用。你可以直接通过EditorGUIUtility.Load去读取该文件夹下的资源。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextAsset test = EditorGUIUtility.Load(<span class="string">&quot;test.txt&quot;</span>) <span class="keyword">as</span> TestAsset;</span><br><span class="line">Debug.Log(Text.text);</span><br></pre></td></tr></table></figure>

<h4 id="Gizmos"><a href="#Gizmos" class="headerlink" title="Gizmos"></a>Gizmos</h4><p>我觉得这个文件夹其实没什么用处，如下代码所示它可以在Scene视图里给某个坐标绘制一个icon。它的好处是可以传一个Vecotor3 作为图片显示的位置。 参数2就是图片的名子，当然这个图片必须放在Gizmos文件夹下面。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Gizmos.DrawIcon(transform.position, <span class="string">&quot;0.png&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想挂在谋和游戏对象身上，那么在Inspector里面就可以直接设置。</p>
<p><img src="/2.png"></p>
<p>这里还是要说说OnDrawGizmos()方法，只要脚本继承了MonoBehaviour后，并且在编辑模式下就会每一帧都执行它。发布的游戏肯定就不会执行了，它只能用于在scene视图中绘制一些小物件。比如要做摄像机轨迹，那么肯定是要在Scene视图中做一个预览的线，那么用Gizmos.DrawLine 和Gizmos.DrawFrustum就再好不过了。</p>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>如果做手机游戏开发一般Android或者ios要接入一些sdk，可以把sdk依赖的库文件放在这里， 比如 .so .jar .a文件，这样打完包以后就会自动把这些文件打在你的包中。</p>
<h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><p> 可以在根目录下，也可以在子目录里，只要名子叫Resources就可以。比如目录：&#x2F;xxx&#x2F;xxx&#x2F;Resources  和 &#x2F;Resources 是一样的，无论多少个叫Resources的文件夹都可以。Resources文件夹下的资源不管你用还是不用都会被打包进.apk或者.ipa</p>
<p>Resource.Load ：编辑时和运行时都可以通过Resource.Load来直接读取。</p>
<p>Resources.LoadAssetAtPath() ：它可以读取Assets目录下的任意文件夹下的资源，它可以在编辑时或者编辑器运行时用，它但是它不能在真机上用，它的路径是”Assets&#x2F;xx&#x2F;xx.xxx” 必须是这种路径，并且要带文件的后缀名。</p>
<p>AssetDatabase.LoadAssetAtPath()：它可以读取Assets目录下的任意文件夹下的资源，它只能在编辑时用。它的路径是”Assets&#x2F;xx&#x2F;xx.xxx” 必须是这种路径，并且要带文件的后缀名。</p>
<p>我觉得在电脑上开发的时候尽量来用Resource.Load() 或者 Resources.LoadAssetAtPath() ，假如手机上选择一部分资源要打assetbundle，一部分资源Resource.Load().那么在做.apk或者.ipa的时候 现在都是用脚本来自动化打包，在打包之前 可以用AssetDatabase.MoveAsset()把已经打包成assetbundle的原始文件从Resources文件夹下移动出去在打包，这样打出来的运行包就不会包行多余的文件了。打完包以后再把移动出去的文件夹移动回来。</p>
<h4 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h4><p>这个文件夹下的资源也会全都打包在.apk或者.ipa 它和Resources的区别是，Resources会压缩文件，但是它不会压缩原封不动的打包进去。并且它是一个只读的文件夹，就是程序运行时只能读 不能写。它在各个平台下的路径是不同的，不过你可以用Application.streamingAssetsPath 它会根据当前的平台选择对应的路径。</p>
<p>有些游戏为了让所有的资源全部使用assetbundle，会把一些初始的assetbundle放在StreamingAssets目录下，运行程序的时候在把这些assetbundle拷贝在Application.persistentDataPath目录下，如果这些assetbundle有更新的话，那么下载到新的assetbundle在把Application.persistentDataPath目录下原有的覆盖掉。</p>
<p>因为Application.persistentDataPath目录是应用程序的沙盒目录，所以打包之前是没有这个目录的，直到应用程序在手机上安装完毕才有这个目录。</p>
<p>StreamingAssets目录下的资源都是不压缩的，所以它比较大会占空间，比如你的应用装在手机上会占用100M的容量，那么你又在StreamingAssets放了一个100M的assetbundle，那么此时在装在手机上就会在200M的容量。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.xuanyusong.com/archives/3229">Unity3D研究院之手游开发中所有特殊的文件夹 | 雨松MOMO程序研究院 (xuanyusong.com)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/29/Unity3D%E6%89%8B%E6%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/" data-id="clmtdoonv0001egru8v5ngqe8" data-title="Unity3D手游开发中的特殊文件夹" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%8B%E6%B8%B8/" rel="tag">手游</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-迭代器和协程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/27/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-27T08:44:08.000Z" itemprop="datePublished">2023-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/27/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B/">迭代器和协程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Unity 里的协程提供了一种异步处理的方式，可以用于实现延迟或者分帧的操作。</p>
<p>Unity 协程的实现基本原理是利用了迭代器。</p>
<h4 id="本文目的："><a href="#本文目的：" class="headerlink" title="本文目的："></a>本文目的：</h4><p>了解迭代器（IEnumerator）和可被迭代接口（IEnumerable）</p>
<hr>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>可以顺序遍历取得一个容器内部的数据，所有实现了接口的 IEnumerable 的 IEnumerator方法的类都可以被迭代（可以用 foreach 遍历）。</p>
<p>迭代器在 List、Map 等容器内经常被使用，一个迭代器基本需要实现三个功能：</p>
<p>​	HasNext：查询是否还有下一个元素</p>
<p>​	MoveNext：将指针移动到下一个元素</p>
<p>​	GetCurrent：获得当前迭代器指向的元素</p>
<p>利用迭代器进行元素遍历的时候，就是不断调用MoveNext和GetCurrent获取所有元素，利用HasNext确定终止条件。</p>
<p><strong>在Unity中的迭代器接口形式为</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中MoveNext()既作为移动指针的作用，又实现了判断是否存在下一个元素的作用。<br>Reset()方法给予了迭代器返回到初始态的能力。</p>
<hr>
<p>现在实现一个自定义的迭代器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; list;</span><br><span class="line">    <span class="built_in">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        currentIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current &#123; <span class="keyword">get</span> =&gt; list[currentIndex]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentIndex &lt; list.Count - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentIndex++;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Ready to Get data from Index <span class="subst">&#123;currentIndex&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;No next data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyEnumerator myEnumerator = <span class="keyword">new</span> MyEnumerator();</span><br><span class="line"><span class="keyword">while</span> (myEnumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(myEnumerator.Current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/1.png"></p>
<p>每次调用MoveNext的时候都会打印一条信息，并在确定成功移动指针的时候，打印当前值。</p>
<p>在没有下一个元素的时候，MoveNext返回 false，循环终止</p>
<p><strong>注意：迭代器会先调用MoveNext方法，在取值，所以初始化的时候currentIndex应带设置成 -1</strong></p>
<hr>
<h4 id="简单的分帧程序"><a href="#简单的分帧程序" class="headerlink" title="简单的分帧程序"></a>简单的分帧程序</h4><p><strong>进入Unity</strong></p>
<p>上文中MoveNext的调用是作为while循环的条件语句，利用while循环是心啊迭代器的遍历。如果将MoveNext的调用改到Update函数中，那么迭代器的遍历就能够在多帧内完成</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumeratorText</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    MyEnumerator myEnumerator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (myEnumerator.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(myEnumerator.Current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myEnumerator.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Frame: &quot;</span> + Time.frameCount);</span><br><span class="line">            <span class="built_in">object</span> current = myEnumerator.Current;</span><br><span class="line">            Debug.Log(current.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/2.png"></p>
<p>元素1和元素2在不同的两帧内被打印出来，在遍历结束后，再调用MoveNext就只能得到 “No next data “ 的日志了。</p>
<p>作为协程，更需要的是分帧执行代码，而非迭代器中的元素，因此Current返回的值并不是很重要，重要的是MoveNext方法能够将指针移动到下一段需要执行的代码。现在将自定义迭代器中原先的 List<int> list 字段改为List&lt;System.Action&gt; actions字段，并重新实现MoveNext和Current接口</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;System.Action&gt; actions;</span><br><span class="line">    <span class="built_in">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        actions = <span class="keyword">new</span> List&lt;System.Action&gt;();</span><br><span class="line">        actions.Add(() =&gt; Debug.Log(<span class="string">&quot;Invoke at first frame.&quot;</span>));</span><br><span class="line">        actions.Add(() =&gt; Debug.Log(<span class="string">&quot;Invoke at second frame.&quot;</span>));</span><br><span class="line">        actions.Add(() =&gt; Debug.Log(<span class="string">&quot;Invoke at third frame&quot;</span>));</span><br><span class="line"></span><br><span class="line">        currentIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current &#123; <span class="keyword">get</span> =&gt; <span class="literal">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentIndex &lt; actions.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            currentIndex++;</span><br><span class="line">            actions[currentIndex].Invoke();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumeratorText</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    MyEnumerator myEnumerator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myEnumerator = <span class="keyword">new</span> MyEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Frame: &quot;</span> + Time.frameCount);</span><br><span class="line">        myEnumerator.MoveNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/3.png"></p>
<p>这样，自定义的迭代器就有了存储操作的能力了，代码运行后分帧执行actions列表中的内容</p>
<h4 id="Unity-协程"><a href="#Unity-协程" class="headerlink" title="Unity 协程"></a>Unity 协程</h4><p>Unity 协程基本利用了迭代器的这种特性，在每一帧中调用迭代器的MoveNext方法，利用MoveNext执行相应代码并移动指针指向下一个需要执行的代码块。当返回值为false的时候，说明迭代器到了尽头，就可以结束调用。而C#提供了 yield return 关键字用于快速实现迭代器，不需要很麻烦的自己再去实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">CoroutineFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;Ready Count!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;End Success&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;The Last.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个 yield return 之间的代码就是MoveNext执行的内容，yield return 后的值就是Current返回的内容。</p>
<p>执行到最后 “The Last.” 代码之后没有了 yield return 语句，则返回false代表迭代器到了终点。这就是协程函数。</p>
<p>调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(CoroutineFunction());</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><img src="/4.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/27/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8D%8F%E7%A8%8B/" data-id="clmtdoooa001iegrugmp86gkx" data-title="迭代器和协程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learn/" rel="tag">learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/" rel="tag">迭代器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-我第一个学会的设计模式：单例模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/28/%E6%88%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%BC%9A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-07-28T08:55:47.000Z" itemprop="datePublished">2023-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/28/%E6%88%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%BC%9A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">我第一个学会的设计模式：单例模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="首次接触"><a href="#首次接触" class="headerlink" title="首次接触"></a>首次接触</h2><p>在跟随<a href="%5B%E9%98%BF%E4%B8%A5Gaming%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%A9%BA%E9%97%B4_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://space.bilibili.com/27164588)">@阿严Gaming</a>老师的横板卷轴飞机大战教程中，第一季接触到了单例模式，虽然不太明白实现的原理，但是感觉很好用，后来也经常在自己的个人项目中用到。</p>


<h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a>单例模式的特点</h3><p>​	1.单例类只能有一个实例。</p>
<p>​	2.单例类必须自己创建自己的唯一实例。</p>
<p>​	3.单例类必须给所有其他对象提供这一实例。</p>
<p>Unity中的单例就是整个场景中有且只有一个的组件：Audio Manager、Game Manager、Scene Loader、UI Manager、记录玩家数据的容器、记录游戏数据的容器等</p>
<p>使用单例模式可以有效防止不同步问题的出现，也可以避免频繁创建对象，节约内存</p>
<h3 id="泛型单例"><a href="#泛型单例" class="headerlink" title="泛型单例"></a>泛型单例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;:<span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态属性可全局访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance &#123;<span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久泛型单例"><a href="#持久泛型单例" class="headerlink" title="持久泛型单例"></a>持久泛型单例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersistentSingleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance &#123;<span class="keyword">get</span> ; <span class="keyword">private</span> <span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建时判断是否已经存在此单例，如果存在就销毁正在创建的</span></span><br><span class="line">        <span class="keyword">if</span>(Instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Instance != <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><p>这是一段挂载在“Audio Manager”物体上的代码，同时该物体上还挂载有Audio Source组件</p>
<h6 id="AudioManager-cs："><a href="#AudioManager-cs：" class="headerlink" title="AudioManager.cs："></a>AudioManager.cs：</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">Singleton</span>&lt;<span class="title">AudioManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> AudioSource musicPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeMusic</span>(<span class="params">AudioClip newClip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        musicPlayer.Stop();</span><br><span class="line">        musicPlayer.clip = newClip;</span><br><span class="line">        musicPlayer.Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中有一个公开的“ChangeMusic”方法，接受一个“AudioClip”类型的参数，用来将正在播放的音乐切换成传入的音频片段</p>
<p>使用方法如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioManager.Instance.ChangeMusic(newClip);</span><br></pre></td></tr></table></figure>

<p>简单好用！</p>
<hr>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>经过网上的搜索，我发现一些传统的单例写法和视频老师教的并不一样，视频老师教的是以继承的方法使用，而下面的是以创建的方法使用：（以我现在的水平，学会一种已经暂时够用了，下面的仅仅是复制粘贴 : D）</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>不管什么语言，单例都可以用以下方法实现：</strong></p>
<ol>
<li>将构造方法私有化，使其不能再类的外部通过new关键字实例化该对象</li>
<li>在该类内部产生一个尾翼的实例化对象，并且将其封装为private static类型</li>
<li>定义一个静态方法返回这个唯一对象</li>
</ol>
<p><strong>同时单例模式又分为“懒汉”模式和“饿汉”模式</strong></p>
<p>​	”懒汉“模式：这个类很懒，只会在你用到它的时候创建自己的实例</p>
<p>​	“饿汉”模式：这个类很勤快，不论你用不用，它都会自动创建自己的实例</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> ()</span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有具体的分类线程安全线程不安全的，我现在的水平有点理解不了</p>
<hr>
<p>2023.8.15  19 : 15 更新</p>
<p>发现一篇解答了我之前疑问的博客，转载一波</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Ww6221905/article/details/114586051">Unity单例模式写法_unity 单例模式_Eraseris的博客-CSDN博客</a></p>
<h2 id="单例一：最简单最常用的写法-A-—-继承于MonoBehaviour"><a href="#单例一：最简单最常用的写法-A-—-继承于MonoBehaviour" class="headerlink" title="单例一：最简单最常用的写法 A — 继承于MonoBehaviour"></a>单例一：最简单最常用的写法 A — 继承于MonoBehaviour</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一个类中调用，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020">Singleton</a>.instance.(方法)。</p>
<h2 id="单例二：升级版单例方法-B-—-继承于MonoBehaviour"><a href="#单例二：升级版单例方法-B-—-继承于MonoBehaviour" class="headerlink" title="单例二：升级版单例方法 B — 继承于MonoBehaviour"></a>单例二：升级版单例方法 B — 继承于MonoBehaviour</h2><p>这个方法，我总是可以在别人的项目里看见，后来才知道这比第一种规范。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = FindObjectOfType(<span class="keyword">typeof</span>(Singleton)) <span class="keyword">as</span> Singleton;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//或者 instance=new GameObject(&quot;[Singleton]&quot;).AddComponent&lt;Singleton&gt;();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一个类中调用，Singleton.instance.(方法)。</p>
<h2 id="单例三：单例方法-C-—-不继承于MonoBehaviour"><a href="#单例三：单例方法-C-—-不继承于MonoBehaviour" class="headerlink" title="单例三：单例方法 C — 不继承于MonoBehaviour"></a>单例三：单例方法 C — 不继承于MonoBehaviour</h2><p>我还碰见一些单例是没有继承的，也就是没有挂在到物体身上的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一个类中调用，Singleton.instance.(方法)。</p>
<p>总结：上述的单例方法中，我们可以进行归纳。其实就是继承和不继承 MonoBehaviour 的单例方法，接下来我们将用到C#语言面向对象的特点（封装、继承、多态），对我们的单例进行一个更好的规范。</p>
<p>还有两种写法，不过我目前是没碰到，我也转载过来了，有兴趣的可以往下看。<br>在这里插入图片描述<br><img src="https://img-blog.csdnimg.cn/20210309161229353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d3NjIyMTkwNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="单例五：最终版E-—-不继承于MonoBehaviour（不随着场景切换而销毁）"><a href="#单例五：最终版E-—-不继承于MonoBehaviour（不随着场景切换而销毁）" class="headerlink" title="单例五：最终版E — 不继承于MonoBehaviour（不随着场景切换而销毁）"></a>单例五：最终版E — 不继承于MonoBehaviour（不随着场景切换而销毁）</h2><p><img src="https://img-blog.csdnimg.cn/20210309161320893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d3NjIyMTkwNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/28/%E6%88%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%BC%9A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="clmtdooo3000eegru7rrd0tb6" data-title="我第一个学会的设计模式：单例模式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%9F%BA%E7%A1%80/" rel="tag">C#基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mipmap/" rel="tag">Mipmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/" rel="tag">learn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/" rel="tag">对象池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E5%8A%9F%E8%83%BD/" rel="tag">小功能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%8B%E6%B8%B8/" rel="tag">手游</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" rel="tag">有限状态机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AC%A3%E5%96%9C%E8%8B%A5%E7%8B%82/" rel="tag">欣喜若狂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/" rel="tag">迭代器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE/" rel="tag">随机播放</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">C#基础</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Mipmap/" style="font-size: 10px;">Mipmap</a> <a href="/tags/UGUI/" style="font-size: 10px;">UGUI</a> <a href="/tags/Unity/" style="font-size: 20px;">Unity</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 10px;">协程</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/" style="font-size: 10px;">对象池</a> <a href="/tags/%E5%B0%8F%E5%8A%9F%E8%83%BD/" style="font-size: 10px;">小功能</a> <a href="/tags/%E6%89%8B%E6%B8%B8/" style="font-size: 10px;">手游</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构与算法</a> <a href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" style="font-size: 10px;">有限状态机</a> <a href="/tags/%E6%AC%A3%E5%96%9C%E8%8B%A5%E7%8B%82/" style="font-size: 10px;">欣喜若狂</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/" style="font-size: 10px;">迭代器</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE/" style="font-size: 10px;">随机播放</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/16/Unity%E5%B0%8F%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AD%8C%E6%9B%B2/">Unity小功能：随机播放列表中的歌曲</a>
          </li>
        
          <li>
            <a href="/2023/09/13/Unity%EF%BC%9AUGUI%E5%9F%BA%E7%A1%80/">Unity：UGUI基础</a>
          </li>
        
          <li>
            <a href="/2023/09/13/%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86Mipmap/">多级渐远纹理Mipmap</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%B3%BB%E7%BB%9F/">设计模式：对象池系统</a>
          </li>
        
          <li>
            <a href="/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">数据结构与算法：排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>